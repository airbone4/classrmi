[
["index.html", "test for class Chapter 1 網路資源", " test for class lend jwj cen 2018-10-28 Chapter 1 網路資源 可以參考 rmd cheat sheet gitbook pimp my rmd ENDMEMO R Package Primer "],
["file-system.html", "Chapter 2 File System 2.1 Exploring file system 2.2 Creating of a directory 2.3 R系統檔案列表 2.4 Constructing of file names in R", " Chapter 2 File System 暫時子目錄 函數 tempfile() 不是建立新檔案,而是在目前的r session中隨機產生唯一檔案名稱，檔案位置預設是在暫時子目錄中。 mydirname &lt;- tempfile(pattern = &quot;mydir&quot;) mydirname [1] &quot;C:\\Users\\linchao\\AppData\\Local\\Temp\\RtmpIp3ZiD 2.1 Exploring file system function file.exists() 可以用來知道檔案是否存在, function dir() 用來知道目前檔案位置的內容. file.exists(mydirname) dir(tempdir()) character(0) # Empty character vector ::: sidebar a &lt;- character(0) identical(a, character(0)) # returns TRUE identical(a, &quot;&quot;) # returns FALSE identical(a, numeric(0)) # returns also FALSE hint: 利用length ::: 2.2 Creating of a directory dir.create 建立子目錄 dir.create(mydirname) file.exists(mydirname) # 上面指令建立的子目錄是否存在 dir(tempdir(), full.names = TRUE) #列出目前子目錄內容(全名) file.mtime(mydirname) #子目錄建立時間,make time [1] TRUE [1] “C:\\Users\\linchao\\AppData\\Local\\Temp\\RtmpIp3ZiD/file87e8755a1876” [2] “C:\\Users\\linchao\\AppData\\Local\\Temp\\RtmpIp3ZiD/mydir87e86b51384d” [3] “C:\\Users\\linchao\\AppData\\Local\\Temp\\RtmpIp3ZiD/rs-graphics-0f3f81af-32b7-49c4-a272-ad1a859f222f” [1] “2018-10-25 23:42:51 CST” 2.3 R系統檔案列表 如果要觀察安裝套件的檔案內無,可以使用指令 system.file(),這個指令可以列出套建的全路徑。例如, system.file(package = &quot;stats&quot;) [1] “C:/PROGRA~1/R/R-3.5.1/library/stats” 列出套件stats中,所有的檔案 dir(system.file(package = &quot;stats&quot;)) [1] “COPYRIGHTS.modreg” “demo” “DESCRIPTION” [4] “help” “html” “INDEX” [7] “libs” “Meta” “NAMESPACE” [10] “R” “SOURCES.ts” 上面可以看到套件中包含子目錄demo，如果還要查看demo中的檔案內容: dir(system.file(&quot;demo&quot;, package = &quot;stats&quot;)) [1] “glm.vr.R” “lm.glm.R” “nlm.R” “smooth.R” 如果要看全路徑，可以: dir(system.file(&quot;demo&quot;, package = &quot;stats&quot;), full.names = TRUE) [1] “/usr/lib64/R/library/stats/demo/glm.vr.R” [2] “/usr/lib64/R/library/stats/demo/lm.glm.R” [3] “/usr/lib64/R/library/stats/demo/nlm.R” [4] “/usr/lib64/R/library/stats/demo/smooth.R” 2.4 Constructing of file names in R 甚麼是檔案名稱?不是 character string 而是 system-specific character string。例如,R函數file.path()的執行結果就是system-specific file names. workingdir &lt;- &quot;projects&quot; projectdir &lt;- &quot;warandpeace&quot; datadir &lt;- &quot;data&quot; file.path(workingdir, projectdir, datadir) [1] “projects/warandpeace/data” 上面是windows 10系統上的結果,比較 Linux-based OS,則為: [1] “projects/warandpeace/data” 注意斜線都一樣。 2.4.1 Note about Windows Why did file.path() put slashes as separator, when we used to backslash in Windows (for example C:\\Program Files\\R\\R-3.3.1)? There is even a special note on it in file.path’s help page: The components are by default separated by ‘/’ (not ‘’) on Windows. Surprisingly DOS and Windows supported slash as file path separator from the beginning. So in most cases one can use as slash, so backslash in Windows. 2.4.2 和工作區相關的指令 dir(), list.files, list.dirs getwd() setwd() list.files(R.home()) ## Only files starting with a-l or r ## Note that a-l is locale-dependent, but using case-insensitive ## matching makes it unambiguous in English locales dir(&quot;../..&quot;, pattern = &quot;^[a-lr]&quot;, full.names = TRUE, ignore.case = TRUE) list.dirs(R.home(&quot;doc&quot;)) list.dirs(R.home(&quot;doc&quot;), full.names = FALSE) "],
["functions.html", "Chapter 3 Functions 3.1 Introduction 3.2 Function fundamentals 3.3 Lexical scoping 3.4 Lazy evaluation 3.5 ... (dot-dot-dot) 3.6 Exiting a function 3.7 Function forms 3.8 Invoking a function 3.9 Quiz answers 3.10 quick view", " Chapter 3 Functions 3.1 Introduction 簡單測試 ### Quiz {-} Answer the following questions to see if you can safely skip this chapter. You can find the answers in ??. What are the three components of a function? What does the following code return? x &lt;- 10 f1 &lt;- function(x) { function() { x + 10 } } f1(1)() How would you usually write this code? `+`(1, `*`(2, 3)) How could you make this call easier to read? mean(, TRUE, x = c(1:10, NA)) Does the following code throw an error when executed? Why/why not? f2 &lt;- function(a, b) { a * 10 } f2(10, stop(&quot;This is an error!&quot;)) What is an infix function? How do you write it? What’s a replacement function? How do you write it? How do you ensure that cleanup action occurs regardless of how a function exits? Outline Section 3.2 describes the basics of creating a function, the three main components of a function, and the exception to many function rules: primitive functions (which are implemented in C, not R). Section 3.3 shows you how R finds the value associated with a given name, i.e. the rules of lexical scoping. Section 3.4 is devoted to an important property of function arguments: they are only evaluated when used for the first time. Section 3.6 discusses the two primary ways that a function can exit, and how to define an exit handler, code that is run on exit, regardless of what triggers it. Section 3.7 shows you the various ways in which R disguises ordinary function calls, and how you can use the standard prefix form to better understand what’s going on. 3.2 Function fundamentals 幾個重要觀念 函數也是物件,就像是vectors 也是物件。 由三個部份組成: arguments, body, and environment. There are exceptions to every rule, and in this case, there is a small selection of “primitive” base functions that are implemented purely in C. 3.2.1 First-class functions 在R中,函數也是物件,這種特性也叫做 “first-class functions”. 如下: f01 &lt;- function(x) { sin(1 / x ^ 2) } 匿名函數: lapply(mtcars, function(x) length(unique(x))) Filter(function(x) !is.numeric(x), mtcars) integrate(function(x) sin(x) ^ 2, 0, pi) 在list中,也可以放入: funs &lt;- list( half = function(x) x / 2, double = function(x) x * 2 ) funs$double(10) #&gt; [1] 20 在R語言中,函數有叫做closure因為,R函數包含(enclose)它們的環境 environments. typeof(f01) #&gt; [1] &quot;closure&quot; 3.2.2 Function components 1個函數有3個部分: formals(), 參數 body(), {}內部. environment(), 決定函數怎樣找出變數(names)的內容。. I’ll draw functions as in the following diagram. The black dot on the left is the environment. The two blocks to the right are the function arguments. I won’t draw the body, because it’s usually large, and doesn’t help you understand the “shape” of the function. The function environment always exists, but it is only printed when the function isn’t defined in the global environment. f02 &lt;- function(x) { # A comment x ^ 2 } formals(f02) #&gt; $x body(f02) #&gt; { #&gt; x^2 #&gt; } environment(f02) #&gt; &lt;environment: R_GlobalEnv&gt; 就像所以其他R的物件,函數也有很多 attributes(). 其中一個 “srcref”, 是 source reference的縮寫。 attr(f02, &quot;srcref&quot;) #&gt; function(x) { #&gt; # A comment #&gt; x ^ 2 #&gt; } 3.2.3 Primitive functions ３個組件的規則有例外，像是 Primitive functions, like sum() and [, 直接調用Ｃ語言。 sum #&gt; function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) `[` #&gt; .Primitive(&quot;[&quot;) 看一下type 分別屬於 “builtin” or “special”: typeof(sum) #&gt; [1] &quot;builtin&quot; typeof(`[`) #&gt; [1] &quot;special&quot; 因此， formals(), body(), and environment() 都回傳 NULL: formals(sum) #&gt; NULL body(sum) #&gt; NULL environment(sum) #&gt; NULL 這些所謂的原始函數，只存在於基本套件(base packages) 。. 3.2.4 Exercises Given a function, like &quot;mean&quot;, match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R? It’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why? function(x) 3() #&gt; function(x) 3() (function(x) 3)() #&gt; [1] 3 A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function? What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function? This code makes a list of all functions in the base package. objs &lt;- mget(ls(&quot;package:base&quot;), inherits = TRUE) funs &lt;- Filter(is.function, objs) Use it to answer the following questions: Which base function has the most arguments? How many base functions have no arguments? What’s special about those functions? How could you adapt the code to find all primitive functions? What are the three important components of a function? When does printing a function not show the environment it was created in? 3.3 Lexical scoping In [Names and values], we discussed assignment, the act of binding a name to a value. Here we’ll discuss scoping, the act of finding the value associated with a name. 下面的執行結果傳回10還是20?1 x &lt;- 10 g01 &lt;- function() { x &lt;- 20 x } g01() 了解範圍規則,有助於函數的模組開發,甚至有助於將R翻譯到其他語言。 lexical scoping 2: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” here is not the English adjective “relating to words or a vocabulary”. It’s a technical CS term that tells us that the scoping rules use a parse-time, rather than a run-time structure. R的’s lexical scoping 遵循4個主要規則:: Name masking Functions vs. variables A fresh start Dynamic lookup 3.3.1 Name masking 內部範圍的宣告(第一次使用)覆蓋外部範圍的宣告。. x &lt;- 10 y &lt;- 20 g02 &lt;- function() { x &lt;- 1 y &lt;- 2 c(x, y) } g02() #&gt; [1] 1 2 如果在內部宣告找不到,就找外一層，一直到global environment。 x &lt;- 2 g03 &lt;- function() { y &lt;- 1 c(x, y) } g03() #&gt; [1] 2 1 上面的規則仍然適用於函數中的函數. 測試:下面的R程式會有甚麼結果 ? 3 x &lt;- 1 g04 &lt;- function() { y &lt;- 2 i &lt;- function() { z &lt;- 3 c(x, y, z) } i() } g04() 同樣也適用於建立函數的函數( closures).參考 [closures]; 這裡只是用來說明上述規則的使用。 g05(), 傳回函數,猜猜執行結果?4 x &lt;- 10 y &lt;- 20 g05 &lt;- function() { y &lt;- 2 function() { c(x, y) } } g06 &lt;- g05() g06() This seems a little magical: how does R know what the value of y is after j() has returned? It works because k preserves the environment in which it was defined and because the environment includes the value of y. You’ll learn more about how environments work in Environments. 3.3.2 Functions vs. variables 既然函數也只是普通的物件,那麼同樣的名稱尋找規則也適用於函數:這個例子中,g07在外部和內部皆有定義。 g07 &lt;- function(x) x + 1 g08 &lt;- function() { g07 &lt;- function(x) x + 100 g07(10) } g08() #&gt; [1] 110 但是如果同一個名稱,在不同範圍有不一樣的型態呢?例如g9一個是變數,一個是函數: g09 &lt;- function(x) x + 100 g10 &lt;- function() { g09 &lt;- 10 g09(g09) } g10() #&gt; [1] 110 一般來講,上面的用法在語法上是沒問題,但是最好避免。 3.3.3 A fresh start 第一次執行和第二次執行有甚麼不同?5 函數 exists(x) :會尋找變數名稱x是否存在,存在則無回 TRUE,否則傳回 FALSE.) g11 &lt;- function() { if (!exists(&quot;a&quot;)) { a &lt;- 1 } else { a &lt;- a + 1 } a } g11() g11() 每次執行的時候,一個新的environment會被建立,用來主導函數的執行。 ??.) 3.3.4 Dynamic lookup Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when it’s created. This means that the output of a function can differ depending on objects outside its environment: g12 &lt;- function() x + 1 x &lt;- 15 g12() #&gt; [1] 16 x &lt;- 20 g12() #&gt; [1] 21 This behaviour can be quite annoying. If you make a spelling mistake in your code, you won’t get an error when you create the function, and you might not even get one when you run the function, depending on what variables are defined in the global environment. One way to detect this problem is to use codetools::findGlobals(). This function lists all the external dependencies (unbound symbols) within a function: codetools::findGlobals(g12) #&gt; [1] &quot;+&quot; &quot;x&quot; Another way to solve the problem would be to manually change the environment of the function to the emptyenv(), an environment which contains nothing: environment(g12) &lt;- emptyenv() g12() #&gt; Error in x + 1: #&gt; could not find function &quot;+&quot; Both of these approaches reveal why this undesirable behaviour exists: R relies on lexical scoping to find everything, even the + operator. This provides a rather beautiful simplicity to R’s scoping rules. 3.3.5 Exercises What does the following code return? Why? Describe how each of the three c’s is interpreted. c &lt;- 10 c(c = c) What are the four principles that govern how R looks for values? What does the following function return? Make a prediction before running the code yourself. f &lt;- function(x) { f &lt;- function(x) { f &lt;- function() { x ^ 2 } f() + 1 } f(x) * 2 } f(10) 3.4 Lazy evaluation In R, function arguments are lazily evaluated: they’re only evaluated if accessed. For example, this code doesn’t generate an error because x is never used: h01 &lt;- function(x) { 10 } h01(stop(&quot;This is an error!&quot;)) #&gt; [1] 10 This is an important feature because it allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed. 3.4.1 Forcing evaluation To compel the evaluation of an argument, use force(): h02 &lt;- function(x) { force(x) 10 } h02(stop(&quot;This is an error!&quot;)) #&gt; Error in force(x): #&gt; This is an error! It is usually not necessary to force evaluation. It’s needed primarily for certain functional programming techniques which we’ll cover in detail in [function operators]. Here, I want to show you the basic issue. Take this small but surprisingly tricky function. It takes a single argument x, and returns a function that returns x when called. capture1 &lt;- function(x) { function() { x } } There’s a subtle issue with this function: the value of x will be captured not when you call capture(), but when you call the function that capture() returns: x &lt;- 10 h03 &lt;- capture1(x) h04 &lt;- capture1(x) h03() #&gt; [1] 10 x &lt;- 20 h04() #&gt; [1] 20 Even more confusingly this only happens once: the value is locked in after you have called h03()/h04() for the first time. x &lt;- 30 h03() #&gt; [1] 10 h04() #&gt; [1] 20 This behaviour is a consequence of lazy evaluation. The x argument is evaluated once h03()/h04() is called, and then its value is cached. We can avoid the confusion by forcing x: capture2 &lt;- function(x) { force(x) function() { x } } x &lt;- 10 h05 &lt;- capture2(x) x &lt;- 20 h05() #&gt; [1] 10 3.4.2 Promises } Lazy evaluation is powered by a data structure called a promise, or (less commonly) a thunk. We’ll come back to this data structure in metaprogramming because it’s one of the features of R that makes it most interesting as a programming language. A promise has three components: The expression, like x + y which gives rise to the delayed computation. The environment where the expression should be evaluated. The value, which is computed and cached when the promise is first accessed by evaluating the expression in the specified environment. The value cache ensures that accessing the promise multiple times always returns the same value. For example, you can see in the following code that runif(1) is only evaluated once: h06 &lt;- function(x) { c(x, x, x) } h06(runif(1)) #&gt; [1] 0.0808 0.0808 0.0808 You can also create promises “by hand” using delayedAssign(): delayedAssign(&quot;x&quot;, {print(&quot;Executing code&quot;); runif(1)}) x #&gt; [1] &quot;Executing code&quot; #&gt; [1] 0.834 x #&gt; [1] 0.834 You’ll see this idea again in advanced bindings. 3.4.3 Default arguments Thanks to lazy evaluation, default value can be defined in terms of other arguments, or even in terms of variables defined later in the function: h07 &lt;- function(x = 1, y = x * 2, z = a + b) { a &lt;- 10 b &lt;- 100 c(x, y, z) } h07() #&gt; [1] 1 2 110 Many base R functions use this technique, but I don’t recommend it. It makes code harder to understand because it requires that you know exactly when default arguments are evaluated in order to predict what they will evaluate to. The evaluation environment is slightly different for default and user supplied arguments, as default arguments are evaluated inside the function. This means that seemingly identical calls can yield different results. It’s easiest to see this with an extreme example: h08 &lt;- function(x = ls()) { a &lt;- 1 x } # ls() evaluated inside f: h08() #&gt; [1] &quot;a&quot; &quot;x&quot; # ls() evaluated in global environment: h08(ls()) #&gt; [1] &quot;f&quot; 3.4.4 Missing arguments If an argument has a default, you can determine if the value comes from the user or the default with missing(): h09 &lt;- function(x = 10) { list(missing(x), x) } str(h09()) #&gt; List of 2 #&gt; $ : logi TRUE #&gt; $ : num 10 str(h09(10)) #&gt; List of 2 #&gt; $ : logi FALSE #&gt; $ : num 10 missing() is best used sparingly. Take sample(), for example. How many arguments are required? args(sample) #&gt; function (x, size, replace = FALSE, prob = NULL) #&gt; NULL It looks like both x and size are required, but in fact sample() uses missing() to provide a default for size if it’s not supplied. If I was to rewrite sample myself6, I’d use an explicit NULL to indicate that size can be supplied, but it’s not required: sample &lt;- function(x, size = NULL, replace = FALSE, prob = NULL) { if (is.null(size)) { size &lt;- length(x) } x[sample.int(length(x), size, replace = replace, prob = prob)] } You can make that pattern even simpler with a small helper. The infix %||% function uses the LHS if it’s not null, otherwise it uses the RHS: `%||%` &lt;- function(lhs, rhs) { if (!is.null(lhs)) { lhs } else { rhs } } sample &lt;- function(x, size = NULL, replace = FALSE, prob = NULL) { size &lt;- size %||% length(x) x[sample.int(length(x), size, replace = replace, prob = prob)] } Because of lazy evaluation, you don’t need to worry about unnecessary computation: the RHS of %||% will only be evaluated if the LHS is null. 3.4.5 Exercises What important property of &amp;&amp; make x_ok() work? x_ok &lt;- function(x) { !is.null(x) &amp;&amp; length(x) == 1 &amp;&amp; x &gt; 0 } x_ok(NULL) #&gt; [1] FALSE x_ok(1) #&gt; [1] TRUE x_ok(1:3) #&gt; [1] FALSE What is different with this code? Why is this behaviour undesirable here? x_ok &lt;- function(x) { !is.null(x) &amp; length(x) == 1 &amp; x &gt; 0 } x_ok(NULL) #&gt; logical(0) x_ok(1) #&gt; [1] TRUE x_ok(1:3) #&gt; [1] FALSE FALSE FALSE The definition of force() is simple: force #&gt; function (x) #&gt; x #&gt; &lt;bytecode: 0x0000000015fe1750&gt; #&gt; &lt;environment: namespace:base&gt; Why is it better to force(x) instead of just x? What does this function return? Why? Which principle does it illustrate? f2 &lt;- function(x = z) { z &lt;- 100 x } f2() What does this function return? Why? Which principle does it illustrate? y &lt;- 10 f1 &lt;- function(x = {y &lt;- 1; 2}, y = 0) { c(x, y) } f1() y In hist(), the default value of xlim is range(breaks), the default value for breaks is &quot;Sturges&quot;, and range(&quot;Sturges&quot;) #&gt; [1] &quot;Sturges&quot; &quot;Sturges&quot; Explain how hist() works to get a correct xlim value. Explain why this function works. Why is it confusing? show_time &lt;- function(x = stop(&quot;Error!&quot;)) { stop &lt;- function(...) Sys.time() print(x) } show_time() #&gt; [1] &quot;2018-10-28 02:19:48 CST&quot; How many arguments are required when calling library()? 3.5 ... (dot-dot-dot) Functions can have a special argument ... (pronounced dot-dot-dot). If a function has this argument, it can take any number of additional arguments. In other programming languages, this type of argument is often called a varargs, or the function is said to be variadic. Inside a function, you can use ... to pass those additional arguments on to another function: i01 &lt;- function(y, z) { list(y = y, z = z) } i02 &lt;- function(x, ...) { i01(...) } str(i02(x = 1, y = 2, z = 3)) #&gt; List of 2 #&gt; $ y: num 2 #&gt; $ z: num 3 It’s possible (but rarely useful) to refer to elements of ... by their position, using a special form: i03 &lt;- function(...) { list(first = ..1, third = ..3) } str(i03(1, 2, 3)) #&gt; List of 2 #&gt; $ first: num 1 #&gt; $ third: num 3 More often useful is list(...), which evaluates the arguments and stores them in a list: i04 &lt;- function(...) { list(...) } str(i04(a = 1, b = 2)) #&gt; List of 2 #&gt; $ a: num 1 #&gt; $ b: num 2 (See also rlang::list2() to support splicing and to silently ignore trailing commas, and rlang::enquos() to capture the unevaluated arguments, the topic of [quasiquotation].) There are two primary uses of ..., both of which we’ll come back to later in the book: If your function takes a function as an argument, you want some way to pass on additional arguments to that function. In this example, lapply() uses ... to pass na.rm on to mean(): x &lt;- list(c(1, 3, NA), c(4, NA, 6)) str(lapply(x, mean, na.rm = TRUE)) #&gt; List of 2 #&gt; $ : num 2 #&gt; $ : num 5 We’ll come back to this technique in Section ??. If your function is an S3 generic, you need some way to allow methods to take arbitrary extra arguments. For example, take the print() function. There are different options for printing types of object, so there’s no way for the print generic to prespecify every possible argument. Instead, it uses ... to allow individual methods to have different arguments: print(factor(letters), max.levels = 4) print(y ~ x, showEnv = TRUE) We’ll come back to this use of ... in Section ??. Using ... comes with two downsides: When you use it to pass arguments on to another function, you have to carefully explain to the user where those arguments go. This makes it hard to understand the what you can do with functions like lapply() and plot(). Any misspelled arguments will not raise an error. This makes it easy for typos to go unnoticed: sum(1, 2, NA, na_rm = TRUE) #&gt; [1] NA ... is a powerful tool, but be aware of the downsides. 3.5.1 Exercises Explain the following results: sum(1, 2, 3) #&gt; [1] 6 mean(1, 2, 3) #&gt; [1] 1 sum(1, 2, 3, na.omit = TRUE) #&gt; [1] 7 mean(1, 2, 3, na.omit = TRUE) #&gt; [1] 1 In the following call, explain how to find the documentation for the named arguments in the following function call: plot(1:10, col = &quot;red&quot;, pch = 20, xlab = &quot;x&quot;, col.lab = &quot;blue&quot;) Why does plot(1:10, col = &quot;red&quot;) only colour the points, not the axes or labels? Read the source code of plot.default() to find out. 3.6 Exiting a function Most functions exit in one of two ways7: either returning a value, indicating successful completion, or throwing an error, indicating failure. This section describes return values (implicit vs. explicit; visible vs. invisible), briefly discusses errors, and introduces exit handlers, which allow you to run code when a function exits, regardless of how it exits. 3.6.1 Implicit vs. explict returns There are two ways that a function can return a value: Implicitly, where the last evaluated expression becomes the return value: j01 &lt;- function(x) { if (x &lt; 10) { 0 } else { 10 } } f(5) #&gt; [1] 52 f(15) #&gt; [1] 452 Explicitly, by calling return(): j02 &lt;- function(x) { if (x &lt; 10) { return(0) } else { return(10) } } 3.6.2 Invisible values Most functions return visibly: calling the function in an interactive context causes the result to be automatically printed. j03 &lt;- function() 1 j03() #&gt; [1] 1 However, it’s also possible to return an invisible() value, which is not automatically printed. j04 &lt;- function() invisible(1) j04() You can verify that the value exists either by explicitly printing it or by wrapping in parentheses: print(j04()) #&gt; [1] 1 (j04()) #&gt; [1] 1 Alternatively, use withVisible() to return the value and a visibility flag: str(withVisible(j04())) #&gt; List of 2 #&gt; $ value : num 1 #&gt; $ visible: logi FALSE The most common function that returns invisibly is &lt;-: a &lt;- 2 (a &lt;- 2) #&gt; [1] 2 And this is what makes it possible to chain assignment: a &lt;- b &lt;- c &lt;- d &lt;- 2 In general, any function called primarily for its side effects (like &lt;-, print(), or plot()) should return an invisible value (typically the value of the first argument). 3.6.3 Errors If a function can not complete its assigned task, it should throw an error with stop(), which immediately terminates the execution of the function. j05 &lt;- function() { stop(&quot;I&#39;m an error&quot;) return(10) } j05() #&gt; Error in j05(): #&gt; I&#39;m an error Errors indicate that something has gone wrong, and force the user to handle them. Some languages (like C, go, and rust) rely on special return values to indicate problems, but in R you should always throw an error. You’ll learn more about errors, and how to handle them, in [Conditions]. 3.6.4 Exit handlers Sometimes a function needs to make a temporary change to global state and you want to ensure those changes are restored when the function completes. It’s painful to make sure you cleanup before any explicit return, and what happens if there’s an error? Instead, you can set up an exiting handler that is called when the function terminates, regardless of whether it returns a value or throws an error. To setup an exiting handler, call on.exit() with the code to be run. It will execute when the function exits, regardless of what causes it to exit: j06 &lt;- function(x) { cat(&quot;Hello\\n&quot;) on.exit(cat(&quot;Goodbye!\\n&quot;), add = TRUE) if (x) { return(10) } else { stop(&quot;Error&quot;) } } f(TRUE) #&gt; [1] 4 f(FALSE) #&gt; [1] 2 Always set add = TRUE when using on.exit(). If you don’t, each call to on.exit() will overwrite the previous exiting handler. Even when only registering a single handler, it’s good practice to set add = TRUE so that you don’t get an unpleasant surprise if you later add more exit handlers on.exit() is important because it allows you to place clean-up actions next to actions with their cleanup operations. cleanup &lt;- function(dir, code) { old_dir &lt;- setwd(dir) on.exit(setwd(old), add = TRUE) old_opt &lt;- options(stringsAsFactors = FALSE) on.exit(options(old_opt), add = TRUE) } When coupled with lazy evaluation, this leads to a very useful pattern for running a block of code in an altered environment: with_dir &lt;- function(dir, code) { old &lt;- setwd(dir) on.exit(setwd(old), add = TRUE) force(code) } getwd() #&gt; [1] &quot;D:/RStudio/mybook&quot; with_dir(&quot;~&quot;, getwd()) #&gt; [1] &quot;C:/Users/linchao/Documents&quot; See the withr package for a collection of functions of this nature. In R 3.4 and prior, on.exit() expressions are always run in the order in which they are created: f &lt;- function() { on.exit(message(&quot;a&quot;), add = TRUE) on.exit(message(&quot;b&quot;), add = TRUE) } f() #&gt; a #&gt; b This can make cleanup a little tricky if some actions need to happen in a specific order; typically you want the most recent added expression to be run first. In R 3.5 and later, you can control this by setting after = FALSE: f &lt;- function() { on.exit(message(&quot;a&quot;), add = TRUE, after = FALSE) on.exit(message(&quot;b&quot;), add = TRUE, after = FALSE) } f() #&gt; b #&gt; a 3.6.5 Exercises What does load() return? Why don’t you normally see these values? What does write.table() return? What would be more useful? How does the chdir parameter of source() compare to in_dir()? Why might you prefer one approach to the other? Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code worked). We can use on.exit() to implement a simple version of capture.output(). capture.output2 &lt;- function(code) { temp &lt;- tempfile() on.exit(file.remove(temp), add = TRUE, after = TRUE) sink(temp) on.exit(sink(), add = TRUE, after = TRUE) force(code) readLines(temp) } capture.output2(cat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, sep = &quot;\\n&quot;)) #&gt; Warning in file.remove(temp): cannot remove file &#39;C: #&gt; \\Users\\linchao\\AppData\\Local\\Temp\\RtmpmqqlIO\\file2dd7419542650&#39;, reason #&gt; &#39;Permission denied&#39; #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Compare capture.output() to capture.output2(). How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas to be easier to understand? 3.7 Function forms &quot;To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.&quot; — John Chambers While everything that happens in R is a result of a function call, not all calls look the same. Function calls come in four varieties: In prefix form, the function name comes before its arguments, like foofy(a, b, c). These constitute of the majority of function calls in R. In infix form, the function name comes inbetween its arguments, like x + y. Infix forms are used for many mathematical operators, as well as user-defined functions that begin and end with %. A replacement function assigns into what looks like a prefix function, like names(df) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;). Special forms like [[, if, and for, don’t have a consistent structure and provide some of the most important syntax in R. While four forms exist, you only need to use one, because any call can be written in prefix form. I’ll demonstrate this property, and then you’ll learn about each of the forms in turn. 3.7.1 Rewriting to prefix form }} An interesting property of R is every infix, replacement, or special form can be rewritten in prefix form. Rewriting in prefix form is useful because it helps you better understand the structure of the language, and it gives you the real name of every function. Knowing the real name of non-prefix functions is useful because it allows you to modify them for fun and profit. The following example shows three pairs of equivalent calls, rewriting an infix form, replacement form, and a special form into prefix form. x + y `+`(x, y) names(df) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) `names&lt;-`(df, c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)) for(i in 1:10) print(i) `for`(i, 1:10, print(i)) Knowing the function name of a non-prefix function allows you to override its behaviour. For example, if you’re ever feeling particularly evil, run the following code while a friend is away from their computer. It will introduce a fun bug: 10% of the time, 1 will be added to any numeric calculation inside of parentheses. `(` &lt;- function(e1) { if (is.numeric(e1) &amp;&amp; runif(1) &lt; 0.1) { e1 + 1 } else { e1 } } replicate(50, (1 + 2)) #&gt; [1] 3 3 4 3 3 3 3 3 3 3 4 3 3 3 3 4 3 3 3 3 3 3 3 3 4 3 3 3 4 3 3 3 3 3 3 #&gt; [36] 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 rm(&quot;(&quot;) Of course, overriding built-in functions like this is a bad idea, but, as you’ll learn about in [metaprogramming], it’s possible to apply it only to selected code blocks. This provides a clean and elegant approach to writing domain specific languages and translators to other languages. A more useful technique is to use this knowledge when using functional programming tools. For example, you could use sapply() to add 3 to every element of a list by first defining a function add(), like this: add &lt;- function(x, y) x + y sapply(1:10, add, 3) #&gt; [1] 4 5 6 7 8 9 10 11 12 13 But we can also get the same effect more simply by relying on the existing + function: sapply(1:5, `+`, 3) #&gt; [1] 4 5 6 7 8 We’ll explore this idea in detail in [functionals]. 3.7.2 Prefix form {prefix-form} The prefix form is the most common form in R code, and indeed in the majority of programming languages. Prefix calls in R are a little special because you can specify arguments in three ways: By position, like help(mean). Using partial matching, like help(to = mean). By name, like help(topic = mean). As illustrated by the following chunk, arguments are matched by exact name, then with unique prefixes, and finally by position. k01 &lt;- function(abcdef, bcde1, bcde2) { list(a = abcdef, b1 = bcde1, b2 = bcde2) } str(k01(1, 2, 3)) #&gt; List of 3 #&gt; $ a : num 1 #&gt; $ b1: num 2 #&gt; $ b2: num 3 str(k01(2, 3, abcdef = 1)) #&gt; List of 3 #&gt; $ a : num 1 #&gt; $ b1: num 2 #&gt; $ b2: num 3 # Can abbreviate long argument names: str(k01(2, 3, a = 1)) #&gt; List of 3 #&gt; $ a : num 1 #&gt; $ b1: num 2 #&gt; $ b2: num 3 # But this doesn&#39;t work because abbreviation is ambiguous str(k01(1, 3, b = 1)) #&gt; Error in k01(1, 3, b = 1): #&gt; argument 3 matches multiple formal arguments Generally, only use positional matching for the first one or two arguments; they will be the most commonly used, and most readers will know what they are. Avoid using positional matching for less commonly used arguments, and never use partial matching. See the tidyverse style guide, http://style.tidyverse.org/syntax.html#argument-names, for more advice. 3.7.3 Infix functions Infix functions are so called because the function name comes inbetween its arguments, and hence infix functions have two arguments. R comes with a number of built-in infix operators: :, ::, :::, $, @, ^, *, /, +, -, &gt;, &gt;=, &lt;, &lt;=, ==, !=, !, &amp;, &amp;&amp;, |, ||, ~, &lt;-, and &lt;&lt;-. You can also create your own infix functions that start and end with %, and base R uses this to additionally define %%, %*%, %/%, %in%, %o%, and %x%. Defining your own infix function is simple. You create a two argument function and bind it to a name that starts and ends with %: `%+%` &lt;- function(a, b) paste0(a, b) &quot;new &quot; %+% &quot;string&quot; #&gt; [1] &quot;new string&quot; The names of infix functions are more flexible than regular R functions: they can contain any sequence of characters except “%”. You will need to escape any special characters in the string used to define the function, but not when you call it: `% %` &lt;- function(a, b) paste(a, b) `%/\\\\%` &lt;- function(a, b) paste(a, b) &quot;a&quot; % % &quot;b&quot; #&gt; [1] &quot;a b&quot; &quot;a&quot; %/\\% &quot;b&quot; #&gt; [1] &quot;a b&quot; R’s default precedence rules mean that infix operators are composed from left to right: `%-%` &lt;- function(a, b) paste0(&quot;(&quot;, a, &quot; %-% &quot;, b, &quot;)&quot;) &quot;a&quot; %-% &quot;b&quot; %-% &quot;c&quot; #&gt; [1] &quot;((a %-% b) %-% c)&quot; There are two special infix functions that can be called with a single argument: + and -. -1 #&gt; [1] -1 +10 #&gt; [1] 10 3.7.4 Replacement functions Replacement functions act like they modify their arguments in place, and have the special name xxx&lt;-. They must have arguments named x and value, and must return the modified object. For example, the following function allows you to modify the second element of a vector: `second&lt;-` &lt;- function(x, value) { x[2] &lt;- value x } Replacement functions are used by placing the function call on the LHS of &lt;-: x &lt;- 1:10 second(x) &lt;- 5L x #&gt; [1] 1 5 3 4 5 6 7 8 9 10 I say they “act” like they modify their arguments in place, because, as discussed in [Modify-in-place], they actually create a modified copy. We can see that by using tracemem(): x &lt;- 1:10 tracemem(x) #&gt; &lt;0x7ffae71bd880&gt; second(x) &lt;- 6L #&gt; tracemem[0x7ffae71bd880 -&gt; 0x7ffae61b5480]: #&gt; tracemem[0x7ffae61b5480 -&gt; 0x7ffae73f0408]: second&lt;- If you want to supply additional arguments, they go inbetween x and value: `modify&lt;-` &lt;- function(x, position, value) { x[position] &lt;- value x } modify(x, 1) &lt;- 10 x #&gt; [1] 10 5 3 4 5 6 7 8 9 10 When you write modify(x, 1) &lt;- 10, behind the scenes R turns it into: x &lt;- `modify&lt;-`(x, 1, 10) Combining replacement with other functions requires more complex translation. For example, this: x &lt;- c(a = 1, b = 2, c = 3) names(x) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; names(x)[2] &lt;- &quot;two&quot; names(x) #&gt; [1] &quot;a&quot; &quot;two&quot; &quot;c&quot; Is translated into: `*tmp*` &lt;- x x &lt;- `names&lt;-`(`*tmp*`, `[&lt;-`(names(`*tmp*`), 2, &quot;two&quot;)) rm(`*tmp*`) (Yes, it really does create a local variable named tmp, which is removed afterwards.) 3.7.5 Special forms Finally, there are a bunch of language features that are usually written in special ways, but also have prefix forms. These include parentheses: (x) (`(`(x)) {x} (`{`(x)). The subsetting operators: x[i] (`[`(x, i)) x[[i]] (`[[`(x, i)) And the tools of control flow: if (cond) true (`if`(cond, true)) if (cond) true else false (`if`(cond, true, false)) for(var in seq) action (`for`(var, seq, action)) while(cond) action (`while`(cond, action)) repeat expr (`repeat`(expr)) next (`next`()) break (`break`()) Finally, the most complex is the “function” function: function(arg1, arg2) {body} (`function`(alist(arg1, arg2), body, env)) Knowing the name of the function that underlies the special form is useful for getting documentation. ?( is a syntax error; ?`(` will give you the documentation for parentheses. Note that all special forms are implemented as primitive functions (i.e. in C); that means printing these functions is not informative: `for` #&gt; .Primitive(&quot;for&quot;) 3.8 Invoking a function Suppose you had a list of function arguments: args &lt;- list(1:10, na.rm = TRUE) How could you then send that list to mean()? In base R, you need do.call(): do.call(mean, args) #&gt; [1] 5.5 # Equivalent to mean(1:10, na.rm = TRUE) #&gt; [1] 5.5 3.8.1 Exercises Rewrite the following code snippets into prefix form: 1 + 2 + 3 1 + (2 + 3) if (length(x) &lt;= 5) x[[5]] else x[[n]] Clarify the following list of odd function calls: x &lt;- sample(replace = TRUE, 20, x = c(1:10, NA)) y &lt;- runif(min = 0, max = 1, 20) cor(m = &quot;k&quot;, y = y, u = &quot;p&quot;, x = x) Explain why the following code fails: modify(get(&quot;x&quot;), 1) &lt;- 10 #&gt; Error: target of assignment expands to non-language object Create a replacement function that modifies a random location in a vector. Write your own version of + that will paste its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work: 1 + 2 #&gt; [1] 3 &quot;a&quot; + &quot;b&quot; #&gt; [1] &quot;ab&quot; Create a list of all the replacement functions found in the base package. Which ones are primitive functions? (Hint use apropros()) What are valid names for user-created infix functions? Create an infix xor() operator. Create infix versions of the set functions intersect(), union(), and setdiff(). You might call them %n%, %u%, and %/% to match conventions from mathematics. 3.9 Quiz answers The three components of a function are its body, arguments, and environment. f1(1)() returns 11. You’d normally write it in infix style: 1 + (2 * 3). Rewriting the call to mean(c(1:10, NA), na.rm = TRUE) is easier to understand. No, it does not throw an error because the second argument is never used so it’s never evaluated. See infix and replacement functions. You use on.exit(); see on exit for details. 3.10 quick view 測試資料 可以先看看資料描述 ?mtcars mtcars #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.62 16.5 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.88 17.0 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.32 18.6 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.21 19.4 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.44 17.0 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.46 20.2 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.57 15.8 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.0 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 18.0 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.42 17.8 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.34 17.4 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.20 19.5 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.61 18.5 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.83 19.9 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.46 20.0 1 0 3 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.52 16.9 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.44 17.3 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.84 15.4 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.85 17.1 0 0 3 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.94 18.9 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 head(mtcars) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 tail(mtcars) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.14 16.7 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 3.10.1 編輯/瀏覽資料 edit(mtcars) data.entry(mtcars) View(mtcars) 3.10.2 個別欄位 如果要顯示個別欄位,一般可以是mtcars$mpg,但是如果要直接使用mpg欄位,可以利用attach() attach(mtcars) mpg #&gt; [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 #&gt; [15] 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 #&gt; [29] 15.8 19.7 15.0 21.4 3.10.3 質性數據的分析 欄位cyl為質性變數,可以利用table分析 table(mtcars$cyl) #&gt; #&gt; 4 6 8 #&gt; 11 7 14 頻率圖 barplot(table(mtcars$cyl)) v&lt;-as.vector(table(mtcars$cyl)) barplot(v) m&lt;-as.matrix(table(mtcars$cyl)) barplot(m) barplot(c(11,7,4)) barplot(mtcars$mpg) barplot(mtcars$cyl) 20.↩ Functions that automatically quote one or more arguments (sometimes called NSE functions) can override the default scoping rules to implement other varieties of scoping. You’ll learn more about that in metaprogramming.↩ g04() returns c(1, 2, 3).↩ g06() returns c(10, 2).↩ g11() 每次被調用都是傳回 1。.↩ Note that this only implements one way of calling sample(): you can also call it with a single integer, like sample(10). This unfortunately makes sample() prone to silent errors in situations like sample(x[i]).↩ Functions can exit in other more esoteric ways like signalling a condition that is caught by an exiting handler, invoking a restart, or pressing “Q” in an interactive browser.↩ "],
["r-packages.html", "Chapter 4 R Packages 4.1 基本 4.2 範例解析 4.3 測試debug 4.4 自製 package 範例", " Chapter 4 R Packages 4.1 基本 4.1.1 reference R 包製作 ### 套件在哪裡 R package and Github 可以DOS指令tree .列出目錄樹結構 R.home() #&gt; [1] &quot;C:/PROGRA~1/R/R-3.5.1&quot; system.file() #&gt; [1] &quot;C:/PROGRA~1/R/R-3.5.1/library/base&quot; system.file(&#39;rmarkdown&#39;) #&gt; [1] &quot;&quot; system.file()除了可以找出套件的根節點以外,也可以視為檔案路徑的在不同系統表示方法的跨平台表示。例如,在package下按照前面的folder順序找檔案 css &lt;- system.file(&quot;rmarkdown&quot;, &quot;templates&quot;, &quot;epurate&quot; ,&quot;resources&quot;, &quot;style.css&quot;, package = &quot;epuRate&quot;) header &lt;- system.file(&quot;rmarkdown&quot;, &quot;templates&quot;, &quot;epurate&quot; ,&quot;resources&quot;, &quot;header.html&quot;, package = &quot;epuRate&quot;) template &lt;- system.file(&quot;rmarkdown&quot;, &quot;templates&quot;, &quot;epurate&quot; ,&quot;resources&quot;, &quot;template_epurate.html&quot;, package = &quot;epuRate&quot;) D:\\RSTUDIO\\RMD\\RPACK\\EPURATE-MASTER\\INST └─rmarkdown └─templates ├─basic │ └─skeleton ├─epurate │ ├─resources │ └─skeleton └─PCTG ├─resources └─skeleton 哪個函數屬於哪個套件? 可以直接打入函數名稱但是不要有括號，看最後一行: R.home #&gt; function (component = &quot;home&quot;) #&gt; { #&gt; rh &lt;- .Internal(R.home()) #&gt; switch(component, home = rh, bin = if (.Platform$OS.type == #&gt; &quot;windows&quot; &amp;&amp; nzchar(p &lt;- .Platform$r_arch)) file.path(rh, #&gt; component, p) else file.path(rh, component), share = if (nzchar(p &lt;- Sys.getenv(&quot;R_SHARE_DIR&quot;))) p else file.path(rh, #&gt; component), doc = if (nzchar(p &lt;- Sys.getenv(&quot;R_DOC_DIR&quot;))) p else file.path(rh, #&gt; component), include = if (nzchar(p &lt;- Sys.getenv(&quot;R_INCLUDE_DIR&quot;))) p else file.path(rh, #&gt; component), modules = if (nzchar(p &lt;- .Platform$r_arch)) file.path(rh, #&gt; component, p) else file.path(rh, component), file.path(rh, #&gt; component)) #&gt; } #&gt; &lt;bytecode: 0x0000000016e40e78&gt; #&gt; &lt;environment: namespace:base&gt; 4.2 範例解析 4.2.1 test system.file(“help”, “AnIndex”, package = “splines”) 結果:[1] “C:/PROGRA1/MICROS4/RCLIEN~1/R_SERVER/library/splines/help/AnIndex” 套件,splines 中,help, AnIndex RTVS debug 互動R document 4.3 測試debug y是局部變數。 x &lt;- 2 g &lt;- function() { y &lt;- 1 c(x, y) } g() #&gt; [1] 2 1 y #&gt; Error in eval(expr, envir, enclos): #&gt; object &#39;y&#39; not found rm(x, g) 4.4 自製 package 範例 package 只有一個data.frame,一個函數. 執行完package.seleton()以後,必須在man子目錄中修改每個RD檔案,title裡面必須有內容。 然後才執行build() trees91.csv rm(list = ls()) ufc &lt;- read.csv(&#39;./resource/trees91.csv&#39;) vol.m3 &lt;- function(dbh.cm, height.m, multiplier = 0.5) { vol.m3 &lt;- pi * (dbh.cm / 200) ^ 2 * height.m * multiplier return(vol.m3) } package.skeleton(name = &quot;xxx&quot;, path = &quot;./packages&quot;, force = TRUE) library(devtools) build(&quot;./packages/xxx&quot;) build(&quot;./packages/xxx&quot;, binary = TRUE) "],
["data-type.html", "Chapter 5 data type 5.1 基本操作 5.2 介紹 5.3 實數的比較 5.4 字串 5.5 型態操作is family 5.6 vector 5.6.1 字串和vector 5.7 List 5.8 vector 函數範例 5.9 matrix 5.10 字串函數 5.11 Regular expression syntax 5.12 Factors 5.13 Tables", " Chapter 5 data type 5.1 基本操作 5.1.1 指派 雖然也可以用=但是，R的設計是使用&lt;-。 a &lt;- 3 a&lt;-3是一個指派的敘述句,不會回饋資訊到螢幕上。如果要知道a的內容是甚麼,就打入a 或者(a&lt;-3) a #&gt; [1] 3 (a&lt;-3) #&gt; [1] 3 b &lt;- sqrt(a * a + 5) b #&gt; [1] 3.74 在session中的如果要列出已經定義過的變數,可以利用ls ls() #&gt; [1] &quot;a&quot; &quot;b&quot; 5.1.2 資源 資料結構 5.2 介紹 在R語言中,型態不須經過宣告(declared)。 一個變數的型態經由assignment的過程決定,即&lt;-右邊的R-Objects。也就是在指派變數值的時候,同時決定了型態。基本的 R-object有 − Vectors Lists Matrices Arrays Factors Data Frames 最簡單的是vector物件,atomic vector 有6種data types(有時也叫做 6 個classes) Data Type Example Logical TRUE, FALSE Numeric 1.3, 5, 99 Integer 3L, 24L, 0L Complex 5 + 4i Character ‘b’ , “good”, “TRUE”, ‘23.4’ Raw “Hello” is stored as 48 65 6c 6c 6f v &lt;- TRUE print(class(v)) #&gt; [1] &quot;logical&quot; v &lt;- 23.5 print(class(v)) #&gt; [1] &quot;numeric&quot; v &lt;- 2L print(class(v)) #&gt; [1] &quot;integer&quot; v &lt;- 2+5i print(class(v)) #&gt; [1] &quot;complex&quot; v &lt;- &quot;TRUE&quot; print(class(v)) #&gt; [1] &quot;character&quot; v &lt;- charToRaw(&quot;Hello&quot;) print(class(v)) #&gt; [1] &quot;raw&quot; 5.3 實數的比較 x &lt;- seq(0, 1, by = 0.2) y &lt;- seq(0, 1, by = 0.2) y[4] #&gt; [1] 0.6 x[3] #&gt; [1] 0.4 1 - x[3] #&gt; [1] 0.6 y[4] == 1 - x[3] #&gt; [1] FALSE y[4] &gt; 1 - x[3] #&gt; [1] TRUE ## note: all.equal(y[4], 1 - x[3]) #&gt; [1] TRUE ## Q: what is the result of : 1-0.4 ==0.6 0.1+0.2 == 0.3 #&gt; [1] FALSE all.equal(0.1+0.2,0.3) #&gt; [1] TRUE 5.4 字串 參考 5.4.1 建立字串 可以是 雙引號中&quot;&quot; 或 單引號中’’。 字串中如果有雙引號,或單引號，則如下表示: “‘這個’來自’那個’” a &lt;- &quot;hello&quot; a #&gt; [1] &quot;hello&quot; typeof(a) #&gt; [1] &quot;character&quot; 利用函數:character() 這個函數的參數,為整數,建立一個list,裡面的元素都是空字串 # 變數ex初始化為character vector,參看後面的討論 (ex &lt;- character(0)) #&gt; character(0) length(ex) #&gt; [1] 0 class(ex) #&gt; [1] &quot;character&quot; # 如果剛剛沒有設定ex &lt;- character(0),這裡會發生錯誤 (ex[1] &lt;- &quot;first&quot;) #&gt; [1] &quot;first&quot; # check its length again length(ex) #&gt; [1] 1 索引可以用跳的: (ex[4] &lt;- &quot;fourth&quot;) #&gt; [1] &quot;fourth&quot; length(ex) #&gt; [1] 4 typeof(ex) #&gt; [1] &quot;character&quot; ex #&gt; [1] &quot;first&quot; NA NA &quot;fourth&quot; 跳過的索引,內容自動為NA. 5.4.2 空字串 引號內連空白都沒有的字串: (比較上面利用character(5)可以建立5個元素為空字串的vector。) # empty string empty_str &lt;- &quot;&quot; empty_str #&gt; [1] &quot;&quot; # class class(empty_str) #&gt; [1] &quot;character&quot; 5.4.2.1 討論character(0) 前面說character(2),可以傳回長度2,每個元素都是空白字串&quot;&quot;的向量,那麼character(0)是甚麼? 除了前面提到的變數初始化為向量(也許可以說是向量宣告) 例如,整數也是這樣 zz&lt;-integer(0) zz[4]=6 zz #&gt; [1] NA NA NA 6 這裡對character(0)做一些測試: ex1&lt;-character(0) ex2&lt;-&quot;&quot; typeof(ex1) #&gt; [1] &quot;character&quot; typeof(ex2) #&gt; [1] &quot;character&quot; str(ex1) #&gt; chr(0) str(ex2) #&gt; chr &quot;&quot; class(ex1) #&gt; [1] &quot;character&quot; class(ex2) #&gt; [1] &quot;character&quot; is.list(ex1) #&gt; [1] FALSE is.list(ex2) #&gt; [1] FALSE surprise: 一個字元也是向量。 is.vector(ex1) #&gt; [1] TRUE is.vector(ex2) #&gt; [1] TRUE length(ex1) #&gt; [1] 0 length(ex2) #&gt; [1] 1 最後,這兩個是不是相等 ex1==ex2 #&gt; logical(0) 5.5 型態操作is family is.numeric(), is.integer(), and is.double() ## 型態轉換 as family a&lt;-c(TRUE,FALSE) as.numeric(a) #&gt; [1] 1 0 an&lt;-as.logical(a) an #&gt; [1] TRUE FALSE 5.6 vector 利用c函數，可以使用vector存放一個以上的數字。 a = c(1, 2, 3, 4, 5) a1 = 1:5 有關list的運算:加減乘除等等 a = c(1, 2, 3, 4, 5) a+1 #&gt; [1] 2 3 4 5 6 mean(a) #&gt; [1] 3 var(a) #&gt; [1] 2.5 summary(a) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 1 2 3 3 4 5 list的元素,利用中括號 a = 2:6 a[1] #&gt; [1] 2 a[2] #&gt; [1] 3 a[0] #&gt; integer(0) a[6] #&gt; [1] NA 在R中,的最小的索引值為1base.如果給索引為0,可以知道資料是否被排序。 超出索引範圍得到&quot;NA。 a=2:6 x = a[6] 如何判斷是否NA x == NA #&gt; [1] NA 上面的比較沒有意義,和NA的任何運算都是NA r = x == NA r #&gt; [1] NA 結論:任何變數和NA運算,結果還是NA 另一種方法 print(x == NA) #&gt; [1] NA 如何判斷NA ? is.na() is.na(a[6]) #&gt; [1] TRUE 初始化向量,可以利用a&lt;-10 或指定numeric(double)型態 a &lt;- numeric(10) a #&gt; [1] 0 0 0 0 0 0 0 0 0 0 如果想要知到變數的資料型別,利用函數typeof() typeof()函數回傳的結果是“字串” typeof(a) # 結果是&quot;double&quot; #&gt; [1] &quot;double&quot; s = typeof(a) s #&gt; [1] &quot;double&quot; typeof(s) #結果是 &quot;character&quot; #&gt; [1] &quot;character&quot; 5.6.1 練習範例 Q1. a,a1,a2 屬於甚麼型態 a = 1:4 a1 = c(1, 2, 3, 4) a2 = numeric(4) A1 Q2:a3的長度是甚麼?2,或6 a1&lt;-c(1,2,3) a2&lt;-c(2,3,4) a3&lt;-c(a1,a2) HINT: a1 a2 a3;length(a3) 5.6.1 字串和vector 在EXCEL中，vector 一般指的是只放元素為數字的陣列(array);而陣列是可以存數字和文字的區域。table是有欄位的陣列。 但是在R語言中,vector 只是元素型態相同即可。 a &lt;- &quot;hello&quot; a #&gt; [1] &quot;hello&quot; typeof(a) #&gt; [1] &quot;character&quot; b &lt;- c(&quot;hello&quot;, &quot;there&quot;) b #&gt; [1] &quot;hello&quot; &quot;there&quot; b[1] #&gt; [1] &quot;hello&quot; typeof(b) #&gt; [1] &quot;character&quot; (a = character(5)) # 產生5個空白字串 #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; (b = letters[1:4]) # 注意,letters不是函數 #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; letters #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; #&gt; [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 因為c函數的運算結果為vector,因此下例中,其元素都是字串 (a&lt;-c(&quot;d&quot;,4,TRUE)) #&gt; [1] &quot;d&quot; &quot;4&quot; &quot;TRUE&quot; 問題: 怎樣知道r是空集合? y &lt;- letters[1:3] z &lt;- letters[4:6] r&lt;-intersect(y,z) r #&gt; character(0) is.na(r) #&gt; logical(0) 另外,當vector有多個字串,而使用索引0的時候,也會出現 character(0),例如: string &lt;- c(&#39;sun&#39;, &#39;sky&#39;, &#39;clouds&#39;) string[0] #&gt; character(0) 5.6.2 vector 相關的運算 連續數字可以利用操作元:,例如: x &lt;- 1:7; x y &lt;- 2:-2; y 比較複雜的序列可以利用函數 seq() ,例如 seq(1, 3, by=0.2) # specify step size #&gt; [1] 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 seq(1, 5, length.out=4) # specify length of the vector #&gt; [1] 1.00 2.33 3.67 5.00 5.6.3 如何存取vector中的元素 元素索引可以利用 logical, integer or character vector. 如果利用整數索引,則從1開始.但是,如果索引值給的是負數(例如-2),則除了2號元素以外,都會被傳回。但是不能同時有正負。同時,浮點數會被truncated。 &gt; x [1] 0 2 4 6 8 10 &gt; x[3] # access 3rd element [1] 4 &gt; x[c(2, 4)] # access 2nd and 4th element [1] 2 6 &gt; x[-1] # access all but 1st element [1] 2 4 6 8 10 &gt; x[c(2, -4)] # 不能混合正負 Error in x[c(2, -4)] : only 0&#39;s may be mixed with negative subscripts &gt; x[c(2.4, 3.54)] # real numbers are truncated to integers [1] 2 4 5.6.4 邏輯做為索引 說是索引有點誤導,可以認為是元素篩選。例如 &gt; x[c(TRUE, FALSE, FALSE, TRUE)] [1] -3 3 &gt; x[x &lt; 0] # filtering vectors based on conditions [1] -3 -1 &gt; x[x &gt; 0] [1] 3 In the above example, the expression x&gt;0 will yield a logical vector (FALSE, FALSE, FALSE, TRUE) which is then used for indexing. 5.6.5 利用字串( character vector) 作為索引 每個元素可以有名稱: &gt; x &lt;- c(&quot;first&quot;=3, &quot;second&quot;=0, &quot;third&quot;=9) &gt; names(x) [1] &quot;first&quot; &quot;second&quot; &quot;third&quot; &gt; x[&quot;second&quot;] second 0 &gt; x[c(&quot;first&quot;, &quot;third&quot;)] first third 3 9 a&lt;-c(x=1:2,y=3:4) a[&quot;x1&quot;] # 不是a[x1] #&gt; x1 #&gt; 1 [] 和[[]]的差別: 原來是甚麼(例如,list 或vector),[]只是返回子集合(仍然是list或vector),但是[[]]則是返回內容. x &lt;- c(a = 1, b = 2, c = 3) x[&quot;a&quot;] #&gt; a #&gt; 1 x[[&quot;a&quot;]] #&gt; [1] 1 x[1] #&gt; a #&gt; 1 x[[1]] #&gt; [1] 1 和list的區別是 1. $ 1. 不必有&quot;&quot; a1&lt;-list(x=1:2,y=3:4) a1$x #&gt; [1] 1 2 5.6.6 How to modify a vector in R? We can modify a vector using the assignment operator. We can use the techniques discussed above to access specific elements and modify them. If we want to truncate the elements, we can use reassignments. &gt; x [1] -3 -2 -1 0 1 2 &gt; x[2] &lt;- 0; x # modify 2nd element [1] -3 0 -1 0 1 2 &gt; x[x&lt;0] &lt;- 5; x # modify elements less than 0 [1] 5 0 5 0 1 2 &gt; x &lt;- x[1:4]; x # truncate x to first 4 elements [1] 5 0 5 0 5.6.7 How to delete a Vector? We can delete a vector by simply assigning a NULL to it. &gt; x [1] -3 -2 -1 0 1 2 &gt; x &lt;- NULL &gt; x NULL &gt; x[4] NULL 5.7 List Lists are the R objects which contain elements of different types like − numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. List is created using list() function. 5.7.1 Creating a List 包含多種type的List: strings, numbers, vectors and a logical values. list_data &lt;- list(&quot;Red&quot;, &quot;Green&quot;, c(21,32,11), TRUE, 51.23, 119.1) print(list_data) #&gt; [[1]] #&gt; [1] &quot;Red&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;Green&quot; #&gt; #&gt; [[3]] #&gt; [1] 21 32 11 #&gt; #&gt; [[4]] #&gt; [1] TRUE #&gt; #&gt; [[5]] #&gt; [1] 51.2 #&gt; #&gt; [[6]] #&gt; [1] 119 ### Naming List Elements The list elements can be given names and they can be accessed using these names. #Create a list containing a vector, a matrix and a list. list_data &lt;- list(c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;), matrix(c(3,9,5,1,-2,8), nrow = 2), list(&quot;green&quot;,12.3)) #Give names to the elements in the list. names(list_data) &lt;- c(&quot;1st Quarter&quot;, &quot;A_Matrix&quot;, &quot;A Inner list&quot;) #Show the list. print(list_data) #&gt; $`1st Quarter` #&gt; [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; #&gt; #&gt; $A_Matrix #&gt; [,1] [,2] [,3] #&gt; [1,] 3 5 -2 #&gt; [2,] 9 1 8 #&gt; #&gt; $`A Inner list` #&gt; $`A Inner list`[[1]] #&gt; [1] &quot;green&quot; #&gt; #&gt; $`A Inner list`[[2]] #&gt; [1] 12.3 5.7.2 Accessing List Elements Elements of the list can be accessed by the index of the element in the list. In case of named lists it can also be accessed using the names. We continue to use the list in the above example − # Create a list containing a vector, a matrix and a list. list_data &lt;- list(c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;), matrix(c(3,9,5,1,-2,8), nrow = 2), list(&quot;green&quot;,12.3)) # Give names to the elements in the list. names(list_data) &lt;- c(&quot;1st Quarter&quot;, &quot;A_Matrix&quot;, &quot;A Inner list&quot;) # Access the first element of the list. print(list_data[1]) #&gt; $`1st Quarter` #&gt; [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; # Access the thrid element. As it is also a list, all its elements will be printed. print(list_data[3]) #&gt; $`A Inner list` #&gt; $`A Inner list`[[1]] #&gt; [1] &quot;green&quot; #&gt; #&gt; $`A Inner list`[[2]] #&gt; [1] 12.3 # Access the list element using the name of the element. print(list_data$A_Matrix) #&gt; [,1] [,2] [,3] #&gt; [1,] 3 5 -2 #&gt; [2,] 9 1 8 5.7.3 Manipulating List Elements We can add, delete and update list elements as shown below. We can add and delete elements only at the end of a list. But we can update any element. # Create a list containing a vector, a matrix and a list. list_data &lt;- list(c(&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;), matrix(c(3,9,5,1,-2,8), nrow = 2), list(&quot;green&quot;,12.3)) # Give names to the elements in the list. names(list_data) &lt;- c(&quot;1st Quarter&quot;, &quot;A_Matrix&quot;, &quot;A Inner list&quot;) # Add element at the end of the list. list_data[4] &lt;- &quot;New element&quot; print(list_data[4]) #&gt; [[1]] #&gt; [1] &quot;New element&quot; # Remove the last element. list_data[4] &lt;- NULL # Print the 4th Element. print(list_data[4]) #&gt; $&lt;NA&gt; #&gt; NULL # Update the 3rd Element. list_data[3] &lt;- &quot;updated element&quot; print(list_data[3]) #&gt; $`A Inner list` #&gt; [1] &quot;updated element&quot; 5.7.4 Merging Lists You can merge many lists into one list by placing all the lists inside one list() function. # Create two lists. list1 &lt;- list(1,2,3) list2 &lt;- list(&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;) # Merge the two lists. merged.list &lt;- c(list1,list2) # Print the merged list. print(merged.list) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 #&gt; #&gt; [[4]] #&gt; [1] &quot;Sun&quot; #&gt; #&gt; [[5]] #&gt; [1] &quot;Mon&quot; #&gt; #&gt; [[6]] #&gt; [1] &quot;Tue&quot; 5.7.5 Converting List to Vector A list can be converted to a vector so that the elements of the vector can be used for further manipulation. All the arithmetic operations on vectors can be applied after the list is converted into vectors. To do this conversion, we use the unlist() function. It takes the list as input and produces a vector. # Create lists. list1 &lt;- list(1:5) print(list1) #&gt; [[1]] #&gt; [1] 1 2 3 4 5 list2 &lt;-list(10:14) print(list2) #&gt; [[1]] #&gt; [1] 10 11 12 13 14 # Convert the lists to vectors. v1 &lt;- unlist(list1) v2 &lt;- unlist(list2) print(v1) #&gt; [1] 1 2 3 4 5 print(v2) #&gt; [1] 10 11 12 13 14 # Now add the vectors result &lt;- v1+v2 print(result) #&gt; [1] 11 13 15 17 19 5.7.6 比較vector, list問題 Q length()函數可以知道vector,list 的長度,但是為甚麼length(“hello”)的長度是1? a&lt;-c(&quot;hello&quot;,&quot;r&quot;) length(a) #&gt; [1] 2 length(a[1]) #&gt; [1] 1 length(a[[1]]) #&gt; [1] 1 nchar(a[1]) #&gt; [1] 5 length(&quot;hello&quot;) #&gt; [1] 1 Q a&lt;-list(&quot;hello&quot;,&quot;r&quot;) length(a) #&gt; [1] 2 length(a[1]) #&gt; [1] 1 length(a[[1]]) #&gt; [1] 1 5.8 vector 函數範例 5.8.1 cbind,rbind x&lt;-runif(5) y&lt;-runif(6) cbind(x,y) #&gt; Warning in cbind(x, y): number of rows of result is not a multiple of #&gt; vector length (arg 1) #&gt; x y #&gt; [1,] 0.0808 0.466 #&gt; [2,] 0.8343 0.498 #&gt; [3,] 0.6008 0.290 #&gt; [4,] 0.1572 0.733 #&gt; [5,] 0.0074 0.773 #&gt; [6,] 0.0808 0.875 5.8.2 函數diff Arguments * x: a numeric vector or matrix containing the values to be differenced. * lag: an integer indicating which lag to use. * differences: an integer indicating the order of the difference. 例如 diff(x,lag=d,differences=n) x[(1+d):n] - x[1:(n-d)] 5.9 matrix matrix(c(1,2,3,4,5,6),2,3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 問題: 怎樣產生 1 2 3 4 5 6 的矩陣 diag(1, nrow = 5) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 0 0 0 0 #&gt; [2,] 0 1 0 0 0 #&gt; [3,] 0 0 1 0 0 #&gt; [4,] 0 0 0 1 0 #&gt; [5,] 0 0 0 0 1 matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, byrow = TRUE, dimnames = list(c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;))) #&gt; c1 c2 c3 #&gt; r1 1 2 3 #&gt; r2 4 5 6 #&gt; r3 7 8 9 m1 &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol = 3) rownames(m1) &lt;- c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;) colnames(m1) &lt;- c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;) m1 #&gt; c1 c2 c3 #&gt; r1 1 4 7 #&gt; r2 2 5 8 #&gt; r3 3 6 9 m1[1, 2] m1[1:2, 2:3] m1[1,] m1[,2] m1[1:2,] m1[, 2:3] m1[-1,] m1[,-2] m1[c(“r1”, “r3”), c(“c1”, “c3”)] m1[1] m1[9] m1[3:7] m1 &gt; 3 m1[m1 &gt; 3] m1 + m1 m1 - 2m1 m1 m1 m1 / m1 m1 ^ 2 m1 %*% m1 t(m1) 5.10 字串函數 5.10.0.1 asic character string functions provided by R: nchar: string length paste: concatenate strings substr: substring toupper: convert entire string to uppercase tolower: convert entire string to lowercase chartr: character map replacement (like “tr”) strtrim：trunates string nchar, substr, toupper, tolower will accept string vectors as arguments and return vector results. strtrim accepts both a vector of strings and a vector of truncation positions. \\': 等同於 &quot;'&quot; . \\&quot;: 等同於 '&quot;'. \\n: newline. \\r: carriage return. \\t: tab character. Note: cat() and print() 處理逃逸字元的方式不一樣如果要在螢幕上解讀上面的字串,需要的是 cat(). print(&quot;a\\nb&quot;) #&gt; [1] &quot;a\\nb&quot; cat(&quot;a\\nb&quot;) #&gt; a #&gt; b 問題: 1. 解釋paste0(c(1,2),c(3,4),collapse=’’) 2. 怎樣得到“1234” 5.11 Regular expression syntax 利用一些特殊字元，例如 $ * + . ? [ ] ^ { } | ( ) \\構成Regular expressions，用來在文字中表達某些搜尋樣式的語法。 這裡只是簡短的介紹 5.11.0.1 Functions which work with regular expression patterns strsplit: split string into substrings at occurances of regexp grep: search for a regular expression within a string sub: search and then replace an occurance of a regular expression in a strng gsub: global search and replace all occurances of a regular expression in a string 5.11.1 Escape sequences 正規表達式中.代表任意字元,但是如果我們要在字串中查找“.”(例如,檔案名稱中的點) 的時候要怎樣表示?答案是使用逃逸字元\\。但是在R語言中,正規表達式，也是使用字串，可是在字串中,\\本身就逃逸字元，因此需要\\\\.。 dot &lt;- &quot;\\\\.&quot; writeLines(dot) #&gt; \\. x &lt;- &quot;a\\\\b&quot; writeLines(x) #&gt; a\\b 5.11.1.1 grep, grepl grep,grepl的差別是後者不支援參數value，且比對的結果和搜尋內容的個數相同。 grep(&quot;a\\\\.c&quot;, c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;)) #&gt; [1] 2 grep(&quot;a\\\\.c&quot;, c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;),value=TRUE) #&gt; [1] &quot;a.c&quot; grepl(&quot;a\\\\.c&quot;, c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;)) #&gt; [1] FALSE TRUE FALSE 又另一個例子,是在字串中尋找單引號,假定要在國家中找尋是否有名稱包含單引號的名字,可以使用'\\'' 問題:為甚麼不是'\\\\'' hint: 這裡的逃逸字元只是字串的標準用法,'不是正規表達式的特殊字元。 country&lt;-read.delim(&#39;resources/country.txt&#39;,header=FALSE) names(country)&lt;-&quot;Name&quot; cname &lt;-levels(country$Name) grep(&#39;\\&#39;&#39;, cname, value = TRUE) #&gt; [1] &quot;Cote d&#39;Ivoire&quot; note: * 不是country.names&lt;-“Name” 問題:下面兩行有甚麼差別? grep(&#39;\\&#39;&#39;, country$Name, value = TRUE) grep(&#39;\\&#39;&#39;, levels(country$Name), value = TRUE) Hint: levels 傳回唯一值 levels(factor(c(&quot;a&quot;,&quot;b&quot;,&quot;a&quot;))) #&gt; [1] &quot;a&quot; &quot;b&quot; factor(c(&quot;a&quot;,&quot;b&quot;,&quot;a&quot;)) #&gt; [1] a b a #&gt; Levels: a b 5.11.1.2 regexpr, gregexpr regexpr 函數的使用方式類似grepl。傳回整數向量(表示符合位置，如果找不到,則傳回-1),個數和比對字串串列相同。這個向量同時有屬性match.length(參考範例) . s&lt;-&quot;a.b.c.9&quot; regexpr(&#39;b&#39;,s ) #&gt; [1] 3 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexpr(&#39;.&#39;,s ) # 要定位符號「.」,這是錯的,\\.也錯 #&gt; [1] 1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexpr(&#39;\\\\.&#39;,s ) # 正確 #&gt; [1] 2 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexpr(&#39;[.]&#39;,s ) # 正確 ,不需要regexpr(&#39;[\\\\.]&#39;,s ) #&gt; [1] 2 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexpr(&#39;\\\\d&#39;,s ) # 正確 #&gt; [1] 7 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE x&lt;-regexpr(&#39;[0-9]&#39;,s ) # 正確 attr(x,&quot;match.length&quot;) #&gt; [1] 1 s&lt;-&quot;a.b.c.9 6 8&quot; x&lt;-regexpr(&#39;[0-9]&#39;,s ) x #&gt; [1] 7 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE attr(x,&quot;match.length&quot;) #&gt; [1] 1 gregexpr() 和 regexpr()一樣,只是會在目標字串中搜尋所有符合的位置而不是只找第一個(g:全局)。 因此傳回的結果個數雖然和查找的串列元素個數一樣,但是每個元素都是一個向量。如果都沒找到,只有一個-1。 s&lt;-&quot;a.b.c.9 6 8&quot; gregexpr(&#39;[0-9]&#39;,s ) #&gt; [[1]] #&gt; [1] 7 9 11 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 1 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 5.11.2 應用 產生3個檔案,檔案名稱含有cat file.create(c(&quot;xcat1.rmd&quot;, &quot;ycat2.txt&quot;, &quot;zcat3.rmd&quot;)) #&gt; [1] TRUE TRUE TRUE files&lt;-list.files(&quot;.&quot;) grep(&quot;cat&quot;, files, value = TRUE) #&gt; [1] &quot;xcat1.rmd&quot; &quot;ycat2.txt&quot; &quot;zcat3.rmd&quot; grep(&quot;cat&quot;, files, value = FALSE) #&gt; [1] 46 48 49 grepl(&quot;cat&quot;, files) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #&gt; [45] FALSE TRUE FALSE TRUE TRUE 5.11.3 數量修飾詞Quantifiers 指定重複次數. *: 至少0個。 +: 至少一個. ?: 最多一個. {n}: 剛好n個. {n,}: 至少n個. {n,m}: 次數在 n 到 m 之間(包括n,m). (strings &lt;- c(&quot;a&quot;, &quot;ab&quot;, &quot;acb&quot;, &quot;accb&quot;, &quot;acccb&quot;, &quot;accccb&quot;)) #&gt; [1] &quot;a&quot; &quot;ab&quot; &quot;acb&quot; &quot;accb&quot; &quot;acccb&quot; &quot;accccb&quot; grep(&quot;ac*b&quot;, strings, value = TRUE) #&gt; [1] &quot;ab&quot; &quot;acb&quot; &quot;accb&quot; &quot;acccb&quot; &quot;accccb&quot; grep(&quot;ac+b&quot;, strings, value = TRUE) #&gt; [1] &quot;acb&quot; &quot;accb&quot; &quot;acccb&quot; &quot;accccb&quot; grep(&quot;ac?b&quot;, strings, value = TRUE) #&gt; [1] &quot;ab&quot; &quot;acb&quot; grep(&quot;ac{2}b&quot;, strings, value = TRUE) #&gt; [1] &quot;accb&quot; grep(&quot;ac{2,}b&quot;, strings, value = TRUE) #&gt; [1] &quot;accb&quot; &quot;acccb&quot; &quot;accccb&quot; grep(&quot;ac{2,3}b&quot;, strings, value = TRUE) #&gt; [1] &quot;accb&quot; &quot;acccb&quot; 5.11.3.1 Exercise Find all countries with ee in Gapminder using quantifiers. #&gt; [1] &quot;Greece&quot; 5.11.4 Position of pattern within the string ^: 字串開頭. $: 字串結尾. \\b: 左右都空白的 word. \\B: 左右不是空白 word. (strings &lt;- c(&quot;abcd&quot;, &quot;cdab&quot;, &quot;cabd&quot;, &quot;c abd&quot;)) #&gt; [1] &quot;abcd&quot; &quot;cdab&quot; &quot;cabd&quot; &quot;c abd&quot; grep(&quot;ab&quot;, strings, value = TRUE) #&gt; [1] &quot;abcd&quot; &quot;cdab&quot; &quot;cabd&quot; &quot;c abd&quot; grep(&quot;^ab&quot;, strings, value = TRUE) #&gt; [1] &quot;abcd&quot; grep(&quot;ab$&quot;, strings, value = TRUE) #&gt; [1] &quot;cdab&quot; grep(&quot;\\\\bab&quot;, strings, value = TRUE) #&gt; [1] &quot;abcd&quot; &quot;c abd&quot; regexpr(&quot;\\\\bab&quot;, strings) #&gt; [1] 1 -1 -1 3 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 2 -1 -1 2 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE regexpr(&quot;\\\\Bab&quot;, strings) #&gt; [1] -1 3 2 -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 2 2 -1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE 5.11.4.1 Exercise Find all .txt files in the repository. #&gt; [1] &quot;ycat2.txt&quot; #&gt; [1] &quot;ycat2.txt&quot; 5.11.5 Operators .: 任意字元。 [...]: 例如,[ade] 3個字元其中一個。[a-e],a到e. [^...]: 除了[]指定的字元，非[…]的意思。. \\: 抑制下列字元在字串,&quot;&quot;,中的特殊意思 $ * + . ? [ ] ^ { } | ( ) \\, 只是在R中,因為\\又有特殊意義 ,因此必須雙\\例如 \\\\$。 |: 或. (...): 字元組,根據出現的順序,可以用 \\\\N識別( backreference). (strings &lt;- c(&quot;^ab&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abd&quot;, &quot;abe&quot;, &quot;ab 12&quot;)) #&gt; [1] &quot;^ab&quot; &quot;ab&quot; &quot;abc&quot; &quot;abd&quot; &quot;abe&quot; &quot;ab 12&quot; grep(&quot;ab.&quot;, strings, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;abd&quot; &quot;abe&quot; &quot;ab 12&quot; grep(&quot;ab[c-e]&quot;, strings, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;abd&quot; &quot;abe&quot; grep(&quot;ab[^c]&quot;, strings, value = TRUE) #&gt; [1] &quot;abd&quot; &quot;abe&quot; &quot;ab 12&quot; grep(&quot;^ab&quot;, strings, value = TRUE) #&gt; [1] &quot;ab&quot; &quot;abc&quot; &quot;abd&quot; &quot;abe&quot; &quot;ab 12&quot; grep(&quot;\\\\^ab&quot;, strings, value = TRUE) #&gt; [1] &quot;^ab&quot; grep(&quot;abc|abd&quot;, strings, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;abd&quot; gsub(&quot;(ab) 12&quot;, &quot;\\\\1 34&quot;, strings) #&gt; [1] &quot;^ab&quot; &quot;ab&quot; &quot;abc&quot; &quot;abd&quot; &quot;abe&quot; &quot;ab 34&quot; note: 要讓.失效，可以[.]或 \\\\. 表示。 5.11.5.1 Excercise 找出國名中間有字元i t 並且將land結尾的字串改為大寫。例如,Finland-&gt;FinLAND #&gt; [1] &quot;FinLAND&quot; &quot;IceLAND&quot; &quot;IreLAND&quot; &quot;SwaziLAND&quot; &quot;SwitzerLAND&quot; #&gt; [6] &quot;ThaiLAND&quot; 5.11.6 Character classes 預設字元分類例如 numbers, letters, 分類。 開頭[: 結尾 :] ，另一種簡寫方式為利用 \\ 。 [:digit:] or \\d: 數字,等同 [0-9]. \\D: 非數字,等同 [^0-9]. [:lower:]: 小寫,等同 [a-z]. [:upper:]: 大寫,等同 [A-Z]. [:alpha:]: 字母,等同 [[:lower:][:upper:]] or [A-z]. [:alnum:]: 等同 [[:alpha:][:digit:]] 或 [A-z0-9]. \\w: word characters, equivalent to [[:alnum:]_] or [A-z0-9_]. \\W: not word, equivalent to [^A-z0-9_]. [:xdigit:]: hexadecimal digits (base 16), 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f, equivalent to [0-9A-Fa-f]. [:blank:]: blank characters, i.e. space and tab. [:space:]: space characters: tab, newline, vertical tab, form feed, carriage return, space. \\s: space, . \\S: not space. [:punct:]: punctuation characters, ! &quot; # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } ~. [:graph:]: graphical (human readable) characters: equivalent to [[:alnum:][:punct:]]. [:print:]: printable characters, equivalent to [[:alnum:][:punct:]\\\\s]. [:cntrl:]: control characters, like \\n or \\r, [\\x00-\\x1F\\x7F]. Note: [:...:] 必須寫在中括號中, 例如 [[:digit:]]. \\ 注意 \\\\d. 和 \\t的區別。 5.12 Factors R也能把資料存為factor(store data is as a factor)。 在大部分實驗中,某些解釋變數經常有不同程度的測試。 (includes trials for different levels of some explanatory variable) The different levels are also called factors. 觀察carbon dioxide 對樹木的生長速率 trees91.csv 1^: tree = read.csv(&quot;./resources/trees91.csv&quot;, header = TRUE, sep = &quot;,&quot;); attributes(tree) #&gt; $names #&gt; [1] &quot;C&quot; &quot;N&quot; &quot;CHBR&quot; &quot;REP&quot; &quot;LFBM&quot; &quot;STBM&quot; &quot;RTBM&quot; #&gt; [8] &quot;LFNCC&quot; &quot;STNCC&quot; &quot;RTNCC&quot; &quot;LFBCC&quot; &quot;STBCC&quot; &quot;RTBCC&quot; &quot;LFCACC&quot; #&gt; [15] &quot;STCACC&quot; &quot;RTCACC&quot; &quot;LFKCC&quot; &quot;STKCC&quot; &quot;RTKCC&quot; &quot;LFMGCC&quot; &quot;STMGCC&quot; #&gt; [22] &quot;RTMGCC&quot; &quot;LFPCC&quot; &quot;STPCC&quot; &quot;RTPCC&quot; &quot;LFSCC&quot; &quot;STSCC&quot; &quot;RTSCC&quot; #&gt; #&gt; $class #&gt; [1] &quot;data.frame&quot; #&gt; #&gt; $row.names #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #&gt; [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #&gt; [47] 47 48 49 50 51 52 53 54 names(tree) #&gt; [1] &quot;C&quot; &quot;N&quot; &quot;CHBR&quot; &quot;REP&quot; &quot;LFBM&quot; &quot;STBM&quot; &quot;RTBM&quot; #&gt; [8] &quot;LFNCC&quot; &quot;STNCC&quot; &quot;RTNCC&quot; &quot;LFBCC&quot; &quot;STBCC&quot; &quot;RTBCC&quot; &quot;LFCACC&quot; #&gt; [15] &quot;STCACC&quot; &quot;RTCACC&quot; &quot;LFKCC&quot; &quot;STKCC&quot; &quot;RTKCC&quot; &quot;LFMGCC&quot; &quot;STMGCC&quot; #&gt; [22] &quot;RTMGCC&quot; &quot;LFPCC&quot; &quot;STPCC&quot; &quot;RTPCC&quot; &quot;LFSCC&quot; &quot;STSCC&quot; &quot;RTSCC&quot; A description of the data file is located at http://cdiac.ornl.gov/ftp/ndp061a/ndp061a.txt . summary(tree$CHBR) #&gt; A1 A2 A3 A4 A5 A6 A7 B1 B2 B3 B4 B5 B6 B7 C1 C2 C3 C4 #&gt; 3 1 1 3 1 3 1 1 3 3 3 3 3 3 1 3 1 3 #&gt; C5 C6 C7 CL6 CL7 D1 D2 D3 D4 D5 D6 D7 #&gt; 1 1 1 1 1 1 1 3 1 1 1 1 在CHBR這個欄位中,因為不全都是數字,因此R自動假定這是一個factor。 summary()函數不會列出5個統計輛,而是列出次數表。 但有些欄位例如C,也是一個factor。但是,R認定為數字,這時必須手動處理。 以下將 tree$C 轉為 factor: tree$C #&gt; [1] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 #&gt; [36] 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 summary(tree$C) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 1.00 2.00 2.00 2.52 3.00 4.00 tree$C &lt;- factor(tree$C) tree$C #&gt; [1] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 #&gt; [36] 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 #&gt; Levels: 1 2 3 4 summary(tree$C) #&gt; 1 2 3 4 #&gt; 8 23 10 13 levels(tree$C) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; 一旦向量轉為一組factors, 5個基本統計量不再有意義。 5.12.1 Data Frames # 順便看看結構 typeof(tree) #&gt; [1] &quot;list&quot; class(tree) #&gt; [1] &quot;data.frame&quot; 既然tree是一個tree,那麼 tree[1] #&gt; C #&gt; 1 1 #&gt; 2 1 #&gt; 3 1 #&gt; 4 1 #&gt; 5 1 #&gt; 6 1 #&gt; 7 1 #&gt; 8 1 #&gt; 9 2 #&gt; 10 2 #&gt; 11 2 #&gt; 12 2 #&gt; 13 2 #&gt; 14 2 #&gt; 15 2 #&gt; 16 2 #&gt; 17 2 #&gt; 18 2 #&gt; 19 2 #&gt; 20 2 #&gt; 21 2 #&gt; 22 2 #&gt; 23 2 #&gt; 24 2 #&gt; 25 2 #&gt; 26 2 #&gt; 27 2 #&gt; 28 2 #&gt; 29 2 #&gt; 30 2 #&gt; 31 2 #&gt; 32 3 #&gt; 33 3 #&gt; 34 3 #&gt; 35 3 #&gt; 36 3 #&gt; 37 3 #&gt; 38 3 #&gt; 39 3 #&gt; 40 3 #&gt; 41 3 #&gt; 42 4 #&gt; 43 4 #&gt; 44 4 #&gt; 45 4 #&gt; 46 4 #&gt; 47 4 #&gt; 48 4 #&gt; 49 4 #&gt; 50 4 #&gt; 51 4 #&gt; 52 4 #&gt; 53 4 #&gt; 54 4 tree[[1]] #&gt; [1] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 #&gt; [36] 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 #&gt; Levels: 1 2 3 4 class(tree[1]) # data.frame #&gt; [1] &quot;data.frame&quot; class(tree[[1]]) # integer #&gt; [1] &quot;factor&quot; typeof(tree[1]) # list #&gt; [1] &quot;list&quot; typeof(tree$C) # integer #&gt; [1] &quot;integer&quot; typeof(tree[[1]]) # integer #&gt; [1] &quot;integer&quot; tree[1] 是一個list tree[[1]] 外圍的tree[]首先被解讀為list類別,然後[1]傳到類別 [[ vs [ 由typeof,class看起來 [[抽取list中的元素 [只是分割list,中的subset 簡單介紹一下手動建立 a &lt;- c(1, 2, 3, 4) b &lt;- c(2, 4, 6, 8) levels &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;)) bubba &lt;- data.frame(first = a, second = b, f = levels) bubba #&gt; first second f #&gt; 1 1 2 A #&gt; 2 2 4 B #&gt; 3 3 6 A #&gt; 4 4 8 B summary(bubba) #&gt; first second f #&gt; Min. :1.00 Min. :2.0 A:2 #&gt; 1st Qu.:1.75 1st Qu.:3.5 B:2 #&gt; Median :2.50 Median :5.0 #&gt; Mean :2.50 Mean :5.0 #&gt; 3rd Qu.:3.25 3rd Qu.:6.5 #&gt; Max. :4.00 Max. :8.0 bubba$first #&gt; [1] 1 2 3 4 bubba$second #&gt; [1] 2 4 6 8 bubba$f #&gt; [1] A B A B #&gt; Levels: A B 5.12.2 Logical Another important data type is the logical type. There are two predefined variables, TRUE and FALSE: a = TRUE typeof(a) #&gt; [1] &quot;logical&quot; b = FALSE typeof(b) #&gt; [1] &quot;logical&quot; The standard logical operators can be used: operator 說明 &lt; less than &gt; great than &lt;= less than or equal &gt;= greater than or equal == equal to != not equal to | entry wise or || or ! not &amp; entry wise and &amp;&amp; and xor(a,b) exclusive or Note that there is a difference between operators that act on entries within a vector and the whole vector: a = c(TRUE, FALSE) b = c(FALSE, FALSE) a | b #&gt; [1] TRUE FALSE a || b #&gt; [1] TRUE xor(a, b) #&gt; [1] TRUE FALSE There are a large number of functions that test to determine the type of a variable. For example the is.numeric function can determine if a variable is numeric: a = c(1, 2, 3) is.numeric(a) #&gt; [1] TRUE is.factor(a) #&gt; [1] FALSE 5.13 Tables 除了data frame 以外,還有table 可以用來組織資料。 這裡只看怎樣建立table,分析分訪看其他。 5.13.1 One Way Tables one-way tables: a table with one row two-way tables: tables with more than one row. table()指令: table uses the cross-classifying factors to build a contingency table of the counts at each combination of factor levels. The arguments it takes is a vector of factors, and it calculates the frequency that each factor occurs. Here is an example of how to create a one way table: a &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;A&quot;, &quot;C&quot;)) results &lt;- table(a) results #&gt; a #&gt; A B C #&gt; 4 3 2 a #&gt; [1] A A B A B B C A C #&gt; Levels: A B C attributes(results) #&gt; $dim #&gt; [1] 3 #&gt; #&gt; $dimnames #&gt; $dimnames$a #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; #&gt; #&gt; #&gt; $class #&gt; [1] &quot;table&quot; summary(results) #&gt; Number of cases in table: 9 #&gt; Number of factors: 1 > class(a) [1] \"factor\" > typeof(a) [1] \"integer\" > a[1] [1] A Levels: A B C > a [1] A A B A B B C A C Levels: A B C > a[[1]] [1] A Levels: A B C > typeof(a[[1]]) [1] \"integer\" > typeof(a[1]) [1] \"integer\" > class(a[[1]]) [1] \"factor\" > class(a[1]) [1] \"factor\" a[1] a[[1]] 都是Factor 沒有[ 和 [[ 的分別.為甚麼? > str(a[[1]]) Factor w/ 3 levels \"A\",\"B\",\"C\": 1 > str(a[1]) Factor w/ 3 levels \"A\",\"B\",\"C\": 1 如果我們知道A有4,個,B有3個,C有2個,能不能直接建立table? 1. 先建立matrix 2. 再加入欄位名稱 3. 利用函數as.table() # step 1 occur &lt;- matrix(c(4, 3, 2), ncol = 3, byrow = TRUE) occur #&gt; [,1] [,2] [,3] #&gt; [1,] 4 3 2 #step 2 colnames(occur) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) occur #&gt; A B C #&gt; [1,] 4 3 2 #step 3 occur &lt;- as.table(occur) occur #&gt; A B C #&gt; A 4 3 2 attributes(occur) #&gt; $dim #&gt; [1] 1 3 #&gt; #&gt; $dimnames #&gt; $dimnames[[1]] #&gt; [1] &quot;A&quot; #&gt; #&gt; $dimnames[[2]] #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; #&gt; #&gt; #&gt; $class #&gt; [1] &quot;table&quot; 5.13.2 Two Way Tables 這個例子中有兩個問題:第1個問題的答案有“Never,” “Sometimes,” or “Always.” 第2個問題的答案有 “Yes,” “No,” or “Maybe.” 兩個問題分別以向量a,b存放( The set of vectors “a,” and “b,” contain the response for each measurement.) a &lt;- c(&quot;Sometimes&quot;, &quot;Sometimes&quot;, &quot;Never&quot;, &quot;Always&quot;, &quot;Always&quot;, &quot;Sometimes&quot;, &quot;Sometimes&quot;, &quot;Never&quot;) b &lt;- c(&quot;Maybe&quot;, &quot;Maybe&quot;, &quot;Yes&quot;, &quot;Maybe&quot;, &quot;Maybe&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;No&quot;) results &lt;- table(a, b) results #&gt; b #&gt; a Maybe No Yes #&gt; Always 2 0 0 #&gt; Never 0 1 1 #&gt; Sometimes 2 1 1 在表格中,可以看到同時回答 “Maybe” “Sometimes” 的個數有幾個。 這裡是另一個直接由我們知道的數據建立table的例子 sexsmoke &lt;- matrix(c(70, 120, 65, 140), ncol = 2, byrow = TRUE) rownames(sexsmoke) &lt;- c(&quot;male&quot;, &quot;female&quot;) colnames(sexsmoke) &lt;- c(&quot;smoke&quot;, &quot;nosmoke&quot;) sexsmoke &lt;- as.table(sexsmoke) sexsmoke #&gt; smoke nosmoke #&gt; male 70 120 #&gt; female 65 140 "],
["assignment.html", "Chapter 6 assignment 6.1 OOP 6.2 operator %&gt;% 6.3 attribute", " Chapter 6 assignment &lt;-和 -&gt; 是一對 ，可以向左和向右賦值 = 是單向的 ，作用和&lt;-基本相同，但對函數中的變數通常使用= &lt;&lt;- 這個是全域賦值 ，跟變數的作用域有關，一般不會用到 ##Delete x (if it exists) rm(x) #&gt; Warning in rm(x): object &#39;x&#39; not found mean(x = 1:10) #[1] 5.5 #&gt; [1] 5.5 x #Error: object &#39;x&#39; not found #&gt; Error in eval(expr, envir, enclos): #&gt; object &#39;x&#39; not found Here x is declared within the function ’s scope of the function, so it doesn ’t exist in the user workspace. Now, let ’s run the same piece of code with using the &lt;- operator: mean(x &lt;- 1:10) # [1] 5.5 #&gt; [1] 5.5 x #&gt; [1] 1 2 3 4 5 6 7 8 9 10 x # [1] 1 2 3 4 5 6 7 8 9 10 This time the x variable is declared within the user workspace. When does the assignment take place ? In the code above, you may be tempted to thing that we “assign 1:10 to x, then calculate the mean.” This would be true for #languages such as C, but it isn ’t true in R. Consider the following function: a &lt;- 1 f &lt;- function(a) return(TRUE) f &lt;- f(a &lt;- a + 1); # 輸出:TRUE a # 結果=1 #&gt; [1] 1 Notice that the value of a hasn ’t changed! In R, the value of a will only change if we need to evaluate the argument in the function. This can lead to unpredictable behaviour: f &lt;- function(a) if (runif(1) &gt; 0.5) TRUE else a f(a &lt;- a + 1); a # result 2 #&gt; [1] 2 f(a &lt;- a + 1); #&gt; [1] TRUE # TRUE a # 2 #&gt; [1] 2 f(a &lt;- a + 1); #&gt; [1] TRUE a #3 #&gt; [1] 2 =用在參數指派 例如 matrix(1:20, ncol = 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 6 11 16 #&gt; [2,] 2 7 12 17 #&gt; [3,] 3 8 13 18 #&gt; [4,] 4 9 14 19 #&gt; [5,] 5 10 15 20 如果 matrix(1:20, ncol &lt;- 4) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 5 9 13 17 #&gt; [2,] 2 6 10 14 18 #&gt; [3,] 3 7 11 15 19 #&gt; [4,] 4 8 12 16 20 ncol #&gt; [1] 4 會產生一個變數 ncol 結論:x&lt;-3 &lt;-會在全局產生變數x然後指派3 (x &lt;- 3) #&gt; [1] 3 #rm(list = ls()) rm(x) ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;bubba&quot; &quot;f&quot; &quot;levels&quot; &quot;ncol&quot; #&gt; [7] &quot;occur&quot; &quot;results&quot; &quot;sexsmoke&quot; &quot;tree&quot; (x = 3) #&gt; [1] 3 ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;bubba&quot; &quot;f&quot; &quot;levels&quot; &quot;ncol&quot; #&gt; [7] &quot;occur&quot; &quot;results&quot; &quot;sexsmoke&quot; &quot;tree&quot; &quot;x&quot; 因為x是參數名稱不是變數,看mean help ## 6.1 OOP advance R ### Base objects vs OO objects To tell the difference between a base and an OO object, use is.object(): A base object: is.object(1:10) #&gt; [1] FALSE [1] FALSE An OO object is.object(mtcars) #&gt; [1] TRUE [1] TRUE (This function would be better called is.oo() because it tells you if an object is a base object or a OO object.) 主要的區別在於基本物件沒有class 這個attribute attr(1:10, &quot;class&quot;) # NULL #&gt; NULL attr(mtcars, “class”) # [1] “data.frame” class()這個函數,不見得總是會和attr()的結果一致,因為，對基本物件而言,傳回的是後面討論,而不是 NULL。 6.2 operator %&gt;% %&gt;% 不是R基礎套件 而是定義再套件 magrittr (CRAN) 且常跟 dplyr (CRAN)搭配。 意思是把左邊(LHS)當成右邊(RHS)的參數。 例如下面的例子: 資料框iris 用來當 head()的參數: 也就是說 iris %&gt;% head() 相當於 head(iris). library(magrittr) iris %&gt;% head() Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa 為甚麼需要這樣用,下面是一個例子 iris %&gt;% head() %&gt;% summary() 類似的觀念, iris %&gt;% head() %&gt;% summary() 等同於summary(head(iris)). 也就是說,避免了使用巢狀呼叫。 6.3 attribute oth the names and the dimensions of matrices and arrays are stored in R as attributes of the object. These attributes can be seen as labeled values you can attach to any object. They form one of the mechanisms R uses to define specific object types like dates, time series, and so on. They can include any kind of information, and you can use them yourself to add information to any object. To see all the attributes of an object, you can use the attributes() function. You can see all the attributes of my.array like this: attributes(my.array) $dim [1] 3 4 2 This function returns a named list, where each item in the list is an attribute. Each attribute can, on itself, be a list again. For example, the attribute dimnames is actually a list containing the row and column names of a matrix. You can check that for yourself by checking the output of attributes(baskets.team). You can set all attributes as a named list as well. You find examples of that in the Help file ?attributes. To get or set a single attribute, you can use the attr() function. This function takes two important arguments. The first argument is the object you want to examine, and the second argument is the name of the attribute you want to see or change. If the attribute you ask for doesn’t exist, R simply returns NULL. Imagine you want to add which season Granny and Geraldine scored the baskets mentioned in baskets.team. You can do this with the following code: attr(baskets.team,‘season’) &lt;- ‘2010-2011’ To get the value of this attribute returned, you can then use following code: attr(baskets.team,‘season’) [1] “2010-2011” You can delete attributes again by setting their value to NULL, like this: attr(baskets.team,‘season’) &lt;- NULL "],
["io.html", "Chapter 7 IO 7.1 csv", " Chapter 7 IO 7.1 csv #列出目前工作目錄上的檔案 x &lt;- dir() for (item in x) { show(item) #print(item) } read.csv(&quot;filename.csv&quot;, #name of file header = TRUE, #are there column names in 1st row? sep = &quot;,&quot;, #what separates rows? as.is = !stringsAsFactors, #turn off automatic conversion of character data to factors colClasses = NA # to convert everything to character data set to &quot;character&quot; na.string = &quot;NA&quot; # could be &quot;.&quot; for SAS files skip = 0, #number of rows to skip at the top of the file. Can be set &gt;0 # if there are comments contained at the top of the file strip.white = TRUE, #strip out extra white space in strings. For example, &quot; 0.1&quot; = &quot;0.1&quot; fill = TRUE, #fill in rows that have unequal numbers of columns comment.char = &quot;#&quot;, #character used for comments that should not be read in stringsAsFactors = FALSE #Another control for deciding whether characters should be converted to factor ) "],
["environments.html", "Chapter 8 Environments 8.1 Introduction 8.2 Environment basics 8.3 Recursing over environments 8.4 Special environments 8.5 The call stack 8.6 As data structures 8.7 &lt;&lt;- 8.8 Quiz answers", " Chapter 8 Environments 參考 https://holtzy.github.io/Pimp-my-rmd/ 8.1 Introduction The environment is the data structure that powers scoping. 相關概念:lexical scoping, namespaces, and R6 classes。 這個文件需要 devtools::install_github(&quot;tidyverse/rlang&quot;) Quiz If you can answer the following questions correctly, you already know the most important topics in this chapter. You can find the answers at the end of the chapter in answers. List at least three ways that an environment is different to a list. What is the parent of the global environment? What is the only environment that doesn’t have a parent? What is the enclosing environment of a function? Why is it important? How do you determine the environment from which a function was called? How are &lt;- and &lt;&lt;- different? Outline Environment basics introduces you to the basic properties of an environment and shows you how to create your own. Recursing over environments provides a function template for computing with environments, illustrating the idea with a useful function. Explicit environments briefly discusses three places where environments are useful data structures for solving other problems. Prerequisites 這個章節利用了套件rlang裡的函數，來探索環境物件。 在rlang套件中,env_函數是設計用來和pipe一起工作的,這裡不深入。 global_env()和globalenv()的執行結果一樣。 .GlobalEnv #&gt; &lt;environment: R_GlobalEnv&gt; globalenv() #&gt; &lt;environment: R_GlobalEnv&gt; global_env() #&gt; &lt;environment: R_GlobalEnv&gt; .BaseNamespaceEnv #&gt; &lt;environment: namespace:base&gt; current_env() # #&gt; &lt;environment: R_GlobalEnv&gt; 8.2 Environment basics 基本上一個 environment 類似名稱串列(named list),但是有4個例外: 名稱唯一(就是變數唯一) 名稱沒有順序關係 會有一個parent 當改變的時候,不會自動複製 (Environments are not copied when modified). 分別探索上面四點: 8.2.1 Basics 要建立environment, 使用 rlang::env(). 類似使用list(),也是一組名稱-值的配對。: e1 &lt;- env( a = FALSE, b = &quot;a&quot;, c = 2.3, d = 1:3 ) 建立environment物件,利用函數 new.env() 不用管參數 hash 和 size。注意不能利用$&lt;-同時定義和建立 parameters; 例如, e1 &lt;- env( ** a &lt;- FALSE ** ) # error . environment物件可以想成是一個袋子,或是names集合。因為沒有次序關係 就像在 names and values, 討論的,這個物件是參考為基礎.(in C concept) 不會有copy on modifying。而且,環境物件可以自己指向自己(recursion) e1$d &lt;- e1 沒有指派的環境變數,只會顯示記憶體位址: e1 #&gt; &lt;environment: 0x000000001cd98ee0&gt; 要知道內容可以使用 env_print() : env_print(e1) #&gt; &lt;environment: 000000001CD98EE0&gt; #&gt; parent: &lt;environment: global&gt; #&gt; bindings: #&gt; * a: &lt;lgl&gt; #&gt; * b: &lt;chr&gt; #&gt; * c: &lt;dbl&gt; #&gt; * d: &lt;env&gt; 想要知道目前有哪些binding(名稱-值 配對)可以利用 env_names() env_names(e1) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; 要列出環境下的繫結，在R 3.2.0 以上,可以使用函數names() ,之前的版本則是 ls(), 但是要注意的是ls 的參數 all.names 內設是 FALSE 因此.開頭的看不到。. 8.2.2 Important environments 另外參考 Special environments。 current_env() 可以知道目前程式碼的執行環境。例如,當我們互動執行RCODE的時候,環境通常是 總體環境,或者由函數global_env()可以得到。這個總體環境有時候就叫“workspace”，同時,這也是函數外面所有互動計算發生的地方。 環境物件的比較不能用==,只能用函數identical()。 identical(global_env(), current_env()) #&gt; [1] TRUE global_env() == current_env() #&gt; Error in global_env() == current_env(): #&gt; comparison (1) is possible only for atomic and list types globalenv() 和.GlobalEnv: 拿到global environmentand。 environment():拿到目前的環境 global environment 的名稱為 R_GlobalEnv 。 global_env() #&gt; &lt;environment: R_GlobalEnv&gt; current_env() #&gt; &lt;environment: R_GlobalEnv&gt; .GlobalEnv #&gt; &lt;environment: R_GlobalEnv&gt; 8.2.3 Parents 每一個環境物件都有一個parent。parent 也一個環境物件。在方塊圖中,parent以藍色圈表示,並用箭頭指向另一個環境物件。 這個parent用來建立 lexical scoping: 如果name沒有在某個環境物件找到,R會重複的在parent中找。 函數env()可以用來建立一個沒有名字的環境 You can set the parent environment by supplying an unnamed argument to env(). If you don’t supply it, it defaults to the current environment. e2a &lt;- env(d = 4, e = 5) e2b &lt;- env(e2a, a = 1, b = 2, c = 3) 函數 env_parent()可以用來找出某個環境物件的parent: env_parent(e2b) #&gt; &lt;environment: 0x000000001ccfe8f0&gt; env_parent(e2a) #&gt; &lt;environment: R_GlobalEnv&gt; parent.env() === env_parent() 所有的環境物件中只有一個名稱為R_EmptyEnv的物件沒有parent(用空心藍色表示): e2c &lt;- env(empty_env(), d = 4, e = 5) e2d &lt;- env(e2c, a = 1, b = 2, c = 3) emptyenv() === empty_env() 試圖利用函數env_parent()找空環境物件的parent會發生錯誤: env_parent(empty_env()) #&gt; Error: The empty environment has no parent 函數 env_parents()可以找出目前環境物件的所有祖先:這個函數會繼續直到遇上global environment 或是空環境物件。上述過程可以利用last環境物件控制。 env_parents(e2b) #&gt; [[1]] &lt;env: 000000001CCFE8F0&gt; #&gt; [[2]] $ &lt;env: global&gt; env_parents(e2d) #&gt; [[1]] &lt;env: 00000000198DC0D0&gt; #&gt; [[2]] $ &lt;env: empty&gt; 可以利用Use parent.env() 找到環境的parent，但是base中沒有可以找出所有祖先的函數。 8.2.4 Getting and setting 存取環境中元素的方法和list類似:使用 $ 和 [[: e3 &lt;- env(x = 1, y = 2) e3$x #&gt; [1] 1 e3$z &lt;- 3 e3[[&quot;z&quot;]] #&gt; [1] 3 但是不能使用 [[ +數字索引,也不能單獨使用 [: e3[[1]] #&gt; Error in e3[[1]]: #&gt; wrong arguments for subsetting an environment e3[c(&quot;x&quot;, &quot;y&quot;)] #&gt; Error in e3[c(&quot;x&quot;, &quot;y&quot;)]: #&gt; object of type &#39;environment&#39; is not subsettable 當環境中的繫結不存在時(簡單點,就是變數不存在時)$ 和 [[ 會傳回 NULL 但不會引發錯誤,如果要有錯誤警告,則利用 env_get() : e3$xyz #&gt; NULL env_get(e3, &quot;xyz&quot;) #&gt; Error in env_get(e3, &quot;xyz&quot;): #&gt; object &#39;xyz&#39; not found 當繫結不存在,但是想要有預設值傳回時,可以利用參數 default . env_get(e3, &quot;xyz&quot;, default = NA) #&gt; [1] NA 另有兩種方式可以在環境物件加入繫結: env_poke()8 takes a name (as string) and a value: env_poke(e3, &quot;a&quot;, 100) e3$a #&gt; [1] 100 env_bind() allows you to bind multiple values: env_bind(e3, a = 10, b = 20) env_names(e3) #&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;a&quot; &quot;b&quot; env_has(): 是否環境中有繫結 env_has(e3, &quot;a&quot;) #&gt; a #&gt; TRUE 不能像是list中刪除元素的方式(指派NULL給元素)，而必須使用 env_unbind(): e3$a &lt;- NULL env_has(e3, &quot;a&quot;) #&gt; a #&gt; TRUE env_unbind(e3, &quot;a&quot;) env_has(e3, &quot;a&quot;) #&gt; a #&gt; FALSE 從一個物件Unbinding 解除名稱，並不會刪除物件，是否刪除物件是 garbage collector的工作.。可以參考 GC. See get(), assign(), exists(), and rm(). These are designed interactively for use with the current environment, so working with other environments is a little clunky. Also beware the inherits argument: it defaults to TRUE meaning that the base equivalents will inspect the supplied environment and all its ancestors. 8.2.5 Finalisers Add something once rlang has an API. Also mention in data structures below 8.2.6 Advanced bindings There are two more exotic variants of env_bind(): env_bind_exprs() creates delayed bindings, which are evaluated the first time they are accessed. Behind the scenes, delayed bindings create promises, so behave in the same way as function arguments. env_bind_exprs(current_env(), b = {Sys.sleep(1); 1}) #&gt; Warning: `env_bind_exprs()` is soft-deprecated as of rlang 0.3.0. #&gt; Please use `env_bind_lazy()` instead. #&gt; This warning is displayed once per session. system.time(print(b)) #&gt; [1] 1 #&gt; user system elapsed #&gt; 0.00 0.00 1.02 system.time(print(b)) #&gt; [1] 1 #&gt; user system elapsed #&gt; 0 0 0 Delayed bindings are used to implement autoload(), which makes R behave as if the package data is in memory, even though it’s only loaded from disk when you ask for it. env_bind_fns() creates active bindings which are re-computed every time they’re accessed: env_bind_fns(current_env(), z1 = function(val) runif(1)) #&gt; Warning: `env_bind_fns()` is soft-deprecated as of rlang 0.3.0. #&gt; Please use `env_bind_active()` instead. #&gt; This warning is displayed once per session. z1 #&gt; [1] 0.0808 z1 #&gt; [1] 0.834 The argument to the function allows you to also override behaviour when the variable is set: env_bind_fns(current_env(), z2 = function(val) { if (missing(val)) { 2 } else { stop(&quot;Don&#39;t touch z2!&quot;, call. = FALSE) } }) z2 #&gt; [1] 2 z2 &lt;- 3 #&gt; Error: Don&#39;t touch z2! See ?delayedAssign() and ?makeActiveBinding(). 8.2.7 Exercises List three ways in which an environment differs from a list. Create an environment as illustrated by this picture. Create a pair of environments as illustrated by this picture. Explain why e[[1]] and e[c(&quot;a&quot;, &quot;b&quot;)] don’t make sense when e is an environment. Create a version of env_poke() that will only bind new names, never re-bind old names. Some programming languages only do this, and are known as single assignment languages. 8.3 Recursing over environments If you want to operate on every ancestor of an environment, it’s often convenient to write a recursive function. This section shows you how, applying your new knowledge of environments to write a function that given a name, finds the environment where() that name is defined, using R’s regular scoping rules. The definition of where() is straightforward. It has two arguments: the name to look for (as a string), and the environment in which to start the search. (We’ll learn why caller_env() is a good default in calling environments.) where &lt;- function(name, env = caller_env()) { if (identical(env, empty_env())) { # Base case stop(&quot;Can&#39;t find &quot;, name, call. = FALSE) } else if (env_has(env, name)) { # Success case env } else { # Recursive case where(name, env_parent(env)) } } 3個情況: The base case: 到達empty environment 沒有parent無法繼續,所以丟出error. The successful case: 在env中找到name ，成功,所以傳回env。. The recursive case: 在env中找不到,繼續在parent中找。. These three cases are illustrated with these three examples: where(&quot;yyy&quot;) #&gt; Error: Can&#39;t find yyy x &lt;- 5 where(&quot;x&quot;) #&gt; &lt;environment: R_GlobalEnv&gt; where(&quot;mean&quot;) #&gt; &lt;environment: base&gt; 想像有兩個環境物件(如圖): e4a &lt;- env(empty_env(), a = 1, b = 2) e4b &lt;- env(e4a, x = 10, a = 11) where(a, e4a) will find a in e4a. where(&quot;b&quot;, e4a) doesn’t find b in e4a, so it looks in its parent, e4b, and finds it there. where(&quot;c&quot;, e4a) looks in e4a, then e4b, then hits the empty environment and throws an error. It’s natural to work with environments recursively, so where() provides a useful template. Removing the specifics of where() shows the structure more clearly: f &lt;- function(..., env = caller_env()) { if (identical(env, empty_env())) { # base case } else if (success) { # success case } else { # recursive case f(..., env = env_parent(env)) } } Iteration vs recursion 也可以用迭代的方式 f2 &lt;- function(..., env = caller_env()) { while (!identical(env, empty_env())) { if (success) { # success case return() } # inspect parent env &lt;- env_parent(env) } # base case } 8.3.1 Exercises Modify where() to return all environments that contain a binding for name. Carefully think through what type of object the function will need to return. Write a function called fget() that finds only function objects. It should have two arguments, name and env, and should obey the regular scoping rules for functions: if there’s an object with a matching name that’s not a function, look in the parent. For an added challenge, also add an inherits argument which controls whether the function recurses up the parents or only looks in one environment. 8.4 Special environments 這裡討論 package environments. 然後探討當函數建立時,綁入函數的函數環境。還有當函數被呼叫時的執行環境(ephemeral)。 套裝環境主要是看這些環境如何支援namespaces。同時,namespace讓package每次載入的時候,都有一樣的行為,而不售其他packages載入先後的影響。 8.4.1 Package environments and the search path 每個套件經由library() 或 require() 接入成為總體環境的parent。而最後一個接入的套件,則是總體環境的第一個parent: load 和 attach不一樣，當我們使用library的時候,我們做的是[^attach] 在環境串列中加入我們利用library載入的物件.. [^attach]: Note the difference between attached and loaded. A package is loaded automatically if you access one of its functions using ::; it is only attached to the search path by library() or require(). env_parent(global_env()) #&gt; &lt;environment: package:rlang&gt; #&gt; attr(,&quot;name&quot;) #&gt; [1] &quot;package:rlang&quot; #&gt; attr(,&quot;path&quot;) #&gt; [1] &quot;C:/Program Files/R/R-3.5.1/library/rlang&quot; And the parent of that package is the second to last package you attached: env_parent(env_parent(global_env())) #&gt; &lt;environment: 0x000000001c92eda8&gt; #&gt; attr(,&quot;name&quot;) #&gt; [1] &quot;mtcars&quot; 如果一層一層parent回朔,就可以到每個套件被接入的順序,這也是R執行中會用到的 search path 因為這些環境的所有物件都可以經由 top-level interactive workspace找到。 search_envs() #&gt; [[1]] $ &lt;env: global&gt; #&gt; [[2]] $ &lt;env: package:rlang&gt; #&gt; [[3]] $ &lt;env: mtcars&gt; #&gt; [[4]] $ &lt;env: package:stats&gt; #&gt; [[5]] $ &lt;env: package:graphics&gt; #&gt; [[6]] $ &lt;env: package:grDevices&gt; #&gt; [[7]] $ &lt;env: package:utils&gt; #&gt; [[8]] $ &lt;env: package:datasets&gt; #&gt; [[9]] $ &lt;env: package:methods&gt; #&gt; [[10]] $ &lt;env: Autoloads&gt; #&gt; [[11]] $ &lt;env: package:base&gt; 函數 search()可以找出環境物件的名稱。 最後兩個環境物件都一樣: Autoloads 環境物件,利用 delayed bindings來節省記憶體，也就是在需要的時候才載入(loading)package中的物件(例如大型資料集)。 base environment, package:base 或簡稱 base, 是base 套裝的環境物件。用來 載入其他套裝(bootstrap)。利用函數 base_env()存取. 利用圖型表示: 當利用 library() attach其他套件的時候, 總體環境的parent馬上改變: 8.4.2 The function environment 當函數被建立的時候,現有的環境會被繫結。稱為function environment, 主要用來支援lexical scoping. 在電腦語言中,當函數紀錄它們的運作環境時,我們說這個函數屬於 closures。,這也是為甚麼這個字眼經常在R語言中出現。. 利用函數 fn_env()可以得到函數的環境物件: y &lt;- 1 f &lt;- function(x) x + y fn_env(f) #&gt; &lt;environment: R_GlobalEnv&gt; 一樣利用函數 environment(f) 可以找到函數 f的環境. 在圖形中,函數被畫成類似子彈,而彈頭的部分繫結環境。 在這個案例中,f()繫結的環境物件,就是繫結名稱f的環境。但並不一定總是這樣，例如在下一個例子中,g被繫結在新環境物件e中。但是函數g()繫結的是global environment。這之間的分別是我們如何找到g和g如何找到他的變數。 e &lt;- env() e$g &lt;- function() 1 8.4.3 Namespaces 在上面的圖形中,我們已經知道套件的parent會隨著之前套件載入的順序不同而不同。這就導致R程式設計者必須保證個別套件上如果使用別的套件的函數，必須是原始目的的那一個。namespaces 就是為此目的而產生: 每個套件必須的使用必須一致,而不管使用者如何載入套件. 以 sd()為例子: sd #&gt; function (x, na.rm = FALSE) #&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), #&gt; na.rm = na.rm)) #&gt; &lt;bytecode: 0x000000001cad62a8&gt; #&gt; &lt;environment: namespace:stats&gt; sd() 必須使用函數 var(), 因此這個var()到底來自 global environment,還是其他接入(attached)的套件的這種問題必須避免。 R avoids this problem by taking advantage of the function vs. binding environment described above. 每個套件中的函數和一對環境物件有關:套件環境(之前學到的)還有namespace環境物件。 package environment: 是套件的外部介面，這是R使用者如何在接入的套件中尋找函數的地方(或者可以利用 ::) package enviromnent 的parent 由搜尋路徑決定(可以利用search()知道)決定(也就是載入的順序) namespace environment:是套件的內部介面。package environment 控制我們如何找到函數,而namespace environment控制函數如何找到變數。 在package environment的每個繫結也可以在namespace environment中找到。這樣可以確保每個函數可以使用套件中的其他函數。但是有些繫結只能在namespace 中找到(例如內部或非輸出物件),這種內部物件通常是用來隱藏一些繁瑣的且不需要給使用者看到的細節。; 每個namespace environment 有一樣的祖集合: 每個namespace有imports的環境物件，其中包含了套件中用到的所有函數繫結。而所謂輸入環境實際由套裝開發人員在檔案NAMESPACE指定 明確的輸入每個base函數,很繁瑣,所以R直接設定import enviroment的parent是base *namespae*[^1]。 The base namespace contains the same bindings as the base environment, but it has different parent. base namespace 的parent是總體環境(#global environment).參考下圖,這種設計導致在import environment中找不到繫結時,會開始再總體環境中尋找,而之前提過總體環境通常是互動環境下名稱搜尋的開始路徑,這也導致搜尋的方式受到套件載入順序的影響。因此,R提供了了R CMD check來警告此種情況的發生。(雖然有麻煩,但是由於S3 方法的dispatch 關係,此種方式仍然留著) 綜合上述,可以得到下圖:: 所以當 sd() 搜尋var 的值的時候,搜尋順序是受到開發者的指定(在檔案NAMESPACE利用import)，而不會受到套裝使用者的影響。這樣保證每次套件程式碼執行的時候,都一樣,而不會受到一般使用者載入套件的順序而影響。 注意在package和namespace兩種環境之間沒有直接的連結.連結是由函數環境定義。 8.4.4 Execution environments execution environment. 下面的函數第一次執行的時候會傳回甚麼?第2次呢? g &lt;- function(x) { if (!env_has(current_env(), &quot;a&quot;)) { message(&quot;Defining a&quot;) a &lt;- 1 } else { a &lt;- a + 1 } a } 再一次利用下面的調用,確認你的答案: g(10) #&gt; Defining a #&gt; [1] 1 g(10) #&gt; Defining a #&gt; [1] 1 g(11) #&gt; Defining a #&gt; [1] 1 這個函數每次執行都傳回一樣的答案,參考 a fresh start. 每次函數被調用的時候,一個新的環境都會被建立來主導執行。這種環境稱為執行環境。而執行環境的parent為 function environment. 用另一個簡單點的例子說明. (圖中,執行環境的parent間接表示:經由函數環境). h &lt;- function(x) { # 1. a &lt;- 2 # 2. x + a } y &lt;- h(1) # 3. 執行環境(execution environment)短暫存在,當函數執行完畢通常會被GC。在幾種情況下,會在記憶體存在比較久,第一種是回傳給另一個變數: h2 &lt;- function(x) { a &lt;- x * 2 current_env() } e &lt;- h2(x = 10) env_print(e) #&gt; &lt;environment: 000000001CEA8650&gt; #&gt; parent: &lt;environment: global&gt; #&gt; bindings: #&gt; * a: &lt;dbl&gt; #&gt; * x: &lt;dbl&gt; fn_env(h2) #&gt; &lt;environment: R_GlobalEnv&gt; Another way to capture it is to return an object with a binding to that environment, like a function. The following example illustrates that idea with a function factory, plus(). We use that factory to create a function called plus_one(). There’s a lot going on in the diagram because the enclosing environment of plus_one() is the execution environment of plus(). plus &lt;- function(x) { function(y) x + y } plus_one &lt;- plus(1) plus_one #&gt; function(y) x + y #&gt; &lt;environment: 0x000000001c8a7338&gt; What happens when we call plus_one()? Its execution environment will have the captured execution environment of plus() as its parent: plus_one(2) #&gt; [1] 3 You’ll learn more about function factories in functional programming. 8.4.5 Exercises How is search_envs() different to env_parents(global_env())? Draw a diagram that shows the enclosing environments of this function: f1 &lt;- function(x1) { f2 &lt;- function(x2) { f3 &lt;- function(x3) { x1 + x2 + x3 } f3(3) } f2(2) } f1(1) Write an enhanced version of str() that provides more information about functions. Show where the function was found and what environment it was defined in. 8.5 The call stack 還有另一種環境稱為 caller environment, 可以經由 rlang::caller_env()存取。. This provides the environment from which the function was called, and hence varies based on how the function is called, not how the function was created. As we saw above this is a useful default whenever you write a function that takes an environment as an argument. parent.frame() is equivalent to caller_env(); just note that it returns an environment, not a frame. To fully understand the caller environment we need to discuss two related concepts: the call stack, which is made up of frames. Executing a function creates two types of context. You’ve learned about one already: the execution environment is a child of the function environment, which is determined by where the function was created. There’s another type of context created by where the function was called: this is called the call stack. There are also a couple of small wrinkles when it comes to custom evaluation. See environments vs. frames for more details. 8.5.1 Simple call stacks Let’s illustrate this with a simple sequence of calls: f() calls g() calls h(). f &lt;- function(x) { g(x = 2) } g &lt;- function(x) { h(x = 3) } h &lt;- function(x) { stop() } The way you most commonly see a call stack in R is by looking at the traceback() after an error has occured: f(x = 1) #&gt; Error: traceback() #&gt; 4: stop() #&gt; 3: h(x = 3) #&gt; 2: g(x = 2) #&gt; 1: f(x = 1) Instead of stop() + traceback() to understand the call stack, we’re going to use lobstr::cst() to print out the call stack tree: h &lt;- function(x) { lobstr::cst() } f(x = 1) #&gt; ??? #&gt; ???f(x = 1) #&gt; ???g(x = 2) #&gt; ???h(x = 3) #&gt; ???lobstr::cst() This shows us that cst() was called from h(), which was called from g(), which was called from f(). Note that the order is the opposite from traceback(). As the call stacks get more compliated, I think it’s easier to understand the sequence of calls if you start from the beginning, rather than the end (i.e. f() calls g(); rather than g() was called by f()). 8.5.2 Lazy evaluation The call stack above is simple - while you get a hint that there’s some tree-like structure involved, everything happens on a single branch. This is typical of a call stack when all arguments are eagerly evaluated. Let’s create a more complicated example that involves some lazy evaluation. We’ll create a sequence of functions, a(), b(), c(), that pass along an argument x. a &lt;- function(x) b(x) b &lt;- function(x) c(x) c &lt;- function(x) x a(f()) #&gt; ??? #&gt; ???a(f()) #&gt; ??? ???b(x) #&gt; ??? ???c(x) #&gt; ???f() #&gt; ???g(x = 2) #&gt; ???h(x = 3) #&gt; ???lobstr::cst() x is lazily evaluated so this tree gets two branches. In the first branch a() calls b(), then b() calls c(). The second branch starts when c() evaluates its argument x. This argument is evaluated in a new branch because the environment in which it is evaluated is the global environment, not the environment of c(). 8.5.3 Frames Each element of the call stack is a frame9, also known as an evaluation context. The frame is an extremely important internal data structure, and R code can only access a small part of the data structure because it’s so critical. A frame has three main components that are accessible from R: An expression (labelled with expr) giving the function call. This is what traceback() prints out. An environment (labelled with env), which is typically the execution environment of a function. There are two main exceptions: the environment of the global frame is the global environment, and calling eval() also generates frames, where the environment can be anything. A parent, the previous call in the call stack (shown by a grey arrow). (To focus on the calling environments, I have omitted the bindings in the global environment from f, g, and h to the respective function objects.) The frame also holds exit handlers created with on.exit(), restarts and handlers for the condition system, and which context to return() to when a function completes. These are important for the internal operation of R, but are not directly accessible. 8.5.4 Dynamic scope Looking up variables in the calling stack rather than in the enclosing environment is called dynamic scoping. Few languages implement dynamic scoping (Emacs Lisp is a notable exception.) This is because dynamic scoping makes it much harder to reason about how a function operates: not only do you need to know how it was defined, you also need to know the context in which it was called. Dynamic scoping is primarily useful for developing functions that aid interactive data analysis. It is one of the topics discussed in non-standard evaluation. 8.5.5 Exercises Write a function that lists all the variables defined in the environment in which it was called. It should return the same results as ls(). 8.6 As data structures As well as powering scoping, environments are also useful data structures in their own right because they have reference semantics. There are three common problems that they can help solve: Avoiding copies of large data. Since environments have reference semantics, you’ll never accidentally create a copy. This makes it a useful vessel for large objects. Bare environments are not that pleasant to work with; I recommend using R6 objects instead. Learn more in [R6]. Managing state within a package. Explicit environments are useful in packages because they allow you to maintain state across function calls. Normally, objects in a package are locked, so you can’t modify them directly. Instead, you can do something like this: my_env &lt;- new.env(parent = emptyenv()) my_env$a &lt;- 1 get_a &lt;- function() { my_env$a } set_a &lt;- function(value) { old &lt;- my_env$a my_env$a &lt;- value invisible(old) } Returning the old value from setter functions is a good pattern because it makes it easier to reset the previous value in conjunction with on.exit() (see more in on exit). As a hashmap. A hashmap is a data structure that takes constant, O(1), time to find an object based on its name. Environments provide this behaviour by default, so can be used to simulate a hashmap. See the CRAN package hash for a complete development of this idea. 8.7 &lt;&lt;- The ancestors of an environment have an important relationship to &lt;&lt;-. The regular assignment arrow, &lt;-, always creates a variable in the current environment. The deep assignment arrow, &lt;&lt;-, never creates a variable in the current environment, but instead modifies an existing variable found by walking up the parent environments. x &lt;- 0 f &lt;- function() { x &lt;&lt;- 1 } f() x #&gt; [1] 1 If &lt;&lt;- doesn’t find an existing variable, it will create one in the global environment. This is usually undesirable, because global variables introduce non-obvious dependencies between functions. &lt;&lt;- is most often used in conjunction with a closure, as described in Closures. 8.7.1 Exercises What does this function do? How does it differ from &lt;&lt;- and why might you prefer it? rebind &lt;- function(name, value, env = caller_env()) { if (identical(env, empty_env())) { stop(&quot;Can&#39;t find `&quot;, name, &quot;`&quot;, call. = FALSE) } else if (env_has(env, name)) { env_poke(env, name, value) } else { rebind(name, value, env_parent(env)) } } rebind(&quot;a&quot;, 10) #&gt; Error: Can&#39;t find `a` a &lt;- 5 rebind(&quot;a&quot;, 10) a #&gt; [1] 10 8.8 Quiz answers There are four ways: every object in an environment must have a name; order doesn’t matter; environments have parents; environments have reference semantics. The parent of the global environment is the last package that you loaded. The only environment that doesn’t have a parent is the empty environment. The enclosing environment of a function is the environment where it was created. It determines where a function looks for variables. Use caller_env() or parent.frame(). &lt;- always creates a binding in the current environment; &lt;&lt;- rebinds an existing name in a parent of the current environment. 8.8.1 term 8.8.1.0.1 global environment :總體環境 8.8.1.0.2 package environments 8.8.1.0.3 imports environment 需要安裝babynames,ggplot2 You might wonder why rlang has env_poke() instead of env_set(). This is for consistency: _set() functions return a modified copy; _poke() functions modify in place.↩ NB: ?environment uses frame in a different sense: “Environments consist of a frame, or collection of named objects, and a pointer to an enclosing environment.”. We avoid this sense of frame, which comes from S, because it’s very specific and not widely used in base R. For example, the “frame” in parent.frame() is an execution context, not a collection of named objects.↩ "],
["tidy-basic-01.html", "Chapter 9 Tidy Basic 01 9.1 long and wide data 9.2 dplyr 9.3 other", " Chapter 9 Tidy Basic 01 require(tidyr) #&gt; Loading required package: tidyr require(dplyr) # data_frame #&gt; Loading required package: dplyr #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union From http://stackoverflow.com/questions/1181060 stocks &lt;- data_frame( time = as.Date(&#39;2009-01-01&#39;) + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4) ) #&gt; Warning: `list_len()` is soft-deprecated as of rlang 0.2.0. #&gt; Please use `new_list()` instead #&gt; This warning is displayed once per session. dset1 &lt;- head(stocks) knitr::kable(dset1, format = &quot;html&quot;) time X Y Z 2009-01-01 -1.400 -1.11 1.87 2009-01-02 0.255 1.26 1.45 2009-01-03 -2.437 4.13 -5.22 2009-01-04 -0.006 -3.26 2.95 2009-01-05 0.622 1.02 7.55 2009-01-06 1.148 -3.73 -0.39 gather(stocks, stock, price, -time) #&gt; # A tibble: 30 x 3 #&gt; time stock price #&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 2009-01-01 X -1.40 #&gt; 2 2009-01-02 X 0.255 #&gt; 3 2009-01-03 X -2.44 #&gt; 4 2009-01-04 X -0.00557 #&gt; 5 2009-01-05 X 0.622 #&gt; 6 2009-01-06 X 1.15 #&gt; 7 2009-01-07 X -1.82 #&gt; 8 2009-01-08 X -0.247 #&gt; 9 2009-01-09 X -0.244 #&gt; 10 2009-01-10 X -0.283 #&gt; # ... with 20 more rows stocks %&gt;% gather(stock, price, -time) #&gt; # A tibble: 30 x 3 #&gt; time stock price #&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 2009-01-01 X -1.40 #&gt; 2 2009-01-02 X 0.255 #&gt; 3 2009-01-03 X -2.44 #&gt; 4 2009-01-04 X -0.00557 #&gt; 5 2009-01-05 X 0.622 #&gt; 6 2009-01-06 X 1.15 #&gt; 7 2009-01-07 X -1.82 #&gt; 8 2009-01-08 X -0.247 #&gt; 9 2009-01-09 X -0.244 #&gt; 10 2009-01-10 X -0.283 #&gt; # ... with 20 more rows dset1 &lt;- head(stocks) knitr::kable(dset1, format = &quot;html&quot;) time X Y Z 2009-01-01 -1.400 -1.11 1.87 2009-01-02 0.255 1.26 1.45 2009-01-03 -2.437 4.13 -5.22 2009-01-04 -0.006 -3.26 2.95 2009-01-05 0.622 1.02 7.55 2009-01-06 1.148 -3.73 -0.39 設定css writeLines(&quot;td, th { padding : 6px } th { background-color : brown ; color : white; border : 1px solid white; } td { color : brown ; border : 1px solid brown }&quot;, con = &quot;tableStyle.css&quot;) stocks &lt;- data_frame( time = as.Date(&#39;2009-01-01&#39;) + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4) ) dset1 &lt;- head(stocks) knitr::kable(dset1, format = &quot;html&quot;) time X Y Z 2009-01-01 0.935 0.140 3.448 2009-01-02 0.176 -1.278 -0.973 2009-01-03 0.244 -0.100 -0.824 2009-01-04 1.624 -0.503 0.077 2009-01-05 0.112 0.890 0.118 2009-01-06 -0.134 5.511 2.199 demo&lt;-gather(stocks, stock, price, -time) dset1 &lt;- head(demo) knitr::kable(dset1, format = &quot;html&quot;) time stock price 2009-01-01 X 0.935 2009-01-02 X 0.176 2009-01-03 X 0.244 2009-01-04 X 1.624 2009-01-05 X 0.112 2009-01-06 X -0.134 9.1 long and wide data 9.1.1 gather: wide to long wide &lt;- data_frame( time = as.Date(&#39;2009-01-01&#39;) + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4) ) long &lt;- gather(wide,stock,price,-time) head(long) #&gt; # A tibble: 6 x 3 #&gt; time stock price #&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 2009-01-01 X 1.07 #&gt; 2 2009-01-02 X -0.665 #&gt; 3 2009-01-03 X 1.11 #&gt; 4 2009-01-04 X -0.246 #&gt; 5 2009-01-05 X -1.18 #&gt; 6 2009-01-06 X -0.976 9.1.2 spread :long to wide wide2 &lt;-spread(long,stock,price) head(wide2) #&gt; # A tibble: 6 x 4 #&gt; time X Y Z #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2009-01-01 1.07 -2.94 7.70 #&gt; 2 2009-01-02 -0.665 0.568 5.19 #&gt; 3 2009-01-03 1.11 2.67 3.00 #&gt; 4 2009-01-04 -0.246 0.473 2.22 #&gt; 5 2009-01-05 -1.18 2.64 -2.19 #&gt; 6 2009-01-06 -0.976 1.05 4.44 更多參考: cookbook for R 9.2 dplyr 函數名 功能 row_number 排序,如果數值一樣,則靠前出現的元素排名在前,例如(3,3) 則 1,2 min_rank 排序,如果數值一樣,則都是同一等級，但是，佔用下一名次。例如 data&lt;-c(3,3,4) data #&gt; [1] 3 3 4 min_rank(data) #&gt; [1] 1 1 3 dense_rank 排序,如果數值一樣,則都是同一等級，但是，不佔用下一名次 data&lt;-c(3,3,4) data #&gt; [1] 3 3 4 dense_rank(data) #&gt; [1] 1 1 2 percent_rank 按百分比的排名 percent_rank = (min_rank(x) - 1)/(sum(!is.na(x)) - 1) cume_dist 累計分佈 ntile : floor(n * (row_number(x) - 1)/len + 1) data&lt;-round(runif(10)*10) pr&lt;-percent_rank(data) cd&lt;-cume_dist(data) mr&lt;-min_rank(data) df&lt;-data.frame(data,pr,mr,cd) arrange(df,data) #&gt; data pr mr cd #&gt; 1 1 0.000 1 0.3 #&gt; 2 1 0.000 1 0.3 #&gt; 3 1 0.000 1 0.3 #&gt; 4 2 0.333 4 0.5 #&gt; 5 2 0.333 4 0.5 #&gt; 6 5 0.556 6 0.6 #&gt; 7 7 0.667 7 0.8 #&gt; 8 7 0.667 7 0.8 #&gt; 9 9 0.889 9 1.0 #&gt; 10 9 0.889 9 1.0 note: (2,3,3,3,3,4,5,6,6,9) 1 2 3 4 5 6 7 8 9 0 1 4 1 1 2 0 0 1 arrange(dataframe, col1, col2, col3) vs. dataframe[order(dataframe\\(col1, dataframe\\)col2, dataframe$col3), ] vs. with(dataframe, dataframe[order(col1, col2, col3), ]) 想要由大到小,例如分數等級 data #&gt; [1] 7 1 9 1 9 1 5 2 7 2 row_number(desc(data)) #&gt; [1] 3 8 1 9 2 10 5 6 4 7 Percentile The nth percentile of an observation variable is the value that cuts off the first n percent of the data values when it is sorted in ascending order. Problem Find the 32nd, 57th and 98th percentiles of runiform(200). data&lt;-runif(200) quantile(data, c(.32, .57, .98)) 9.3 other library(babynames) babynames #&gt; # A tibble: 1,858,689 x 5 #&gt; year sex name n prop #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1880 F Mary 7065 0.0724 #&gt; 2 1880 F Anna 2604 0.0267 #&gt; 3 1880 F Emma 2003 0.0205 #&gt; 4 1880 F Elizabeth 1939 0.0199 #&gt; 5 1880 F Minnie 1746 0.0179 #&gt; 6 1880 F Margaret 1578 0.0162 #&gt; 7 1880 F Ida 1472 0.0151 #&gt; 8 1880 F Alice 1414 0.0145 #&gt; 9 1880 F Bertha 1320 0.0135 #&gt; 10 1880 F Sarah 1288 0.0132 #&gt; # ... with 1,858,679 more rows 9.3.1 Basic verbs babynames %&gt;% select(-prop) #&gt; # A tibble: 1,858,689 x 4 #&gt; year sex name n #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1880 F Mary 7065 #&gt; 2 1880 F Anna 2604 #&gt; 3 1880 F Emma 2003 #&gt; 4 1880 F Elizabeth 1939 #&gt; 5 1880 F Minnie 1746 #&gt; 6 1880 F Margaret 1578 #&gt; 7 1880 F Ida 1472 #&gt; 8 1880 F Alice 1414 #&gt; 9 1880 F Bertha 1320 #&gt; 10 1880 F Sarah 1288 #&gt; # ... with 1,858,679 more rows babynames %&gt;% select(year:n) #&gt; # A tibble: 1,858,689 x 4 #&gt; year sex name n #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 1880 F Mary 7065 #&gt; 2 1880 F Anna 2604 #&gt; 3 1880 F Emma 2003 #&gt; 4 1880 F Elizabeth 1939 #&gt; 5 1880 F Minnie 1746 #&gt; 6 1880 F Margaret 1578 #&gt; 7 1880 F Ida 1472 #&gt; 8 1880 F Alice 1414 #&gt; 9 1880 F Bertha 1320 #&gt; 10 1880 F Sarah 1288 #&gt; # ... with 1,858,679 more rows # starts_with(), ends_with(), contains() babynames %&gt;% filter(name == &quot;Hadley&quot;) #&gt; # A tibble: 159 x 5 #&gt; year sex name n prop #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1906 M Hadley 6 0.0000416 #&gt; 2 1908 M Hadley 16 0.0000962 #&gt; 3 1909 M Hadley 14 0.0000792 #&gt; 4 1910 M Hadley 5 0.0000240 #&gt; 5 1911 M Hadley 9 0.0000373 #&gt; 6 1912 M Hadley 11 0.0000244 #&gt; 7 1913 M Hadley 10 0.0000186 #&gt; 8 1914 M Hadley 15 0.0000220 #&gt; 9 1915 M Hadley 14 0.0000159 #&gt; 10 1916 M Hadley 14 0.0000152 #&gt; # ... with 149 more rows babynames %&gt;% filter(year == 1900, sex == &quot;F&quot;) #&gt; # A tibble: 2,225 x 5 #&gt; year sex name n prop #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1900 F Mary 16707 0.0526 #&gt; 2 1900 F Helen 6343 0.0200 #&gt; 3 1900 F Anna 6114 0.0192 #&gt; 4 1900 F Margaret 5304 0.0167 #&gt; 5 1900 F Ruth 4765 0.0150 #&gt; 6 1900 F Elizabeth 4096 0.0129 #&gt; 7 1900 F Florence 3920 0.0123 #&gt; 8 1900 F Ethel 3896 0.0123 #&gt; 9 1900 F Marie 3856 0.0121 #&gt; 10 1900 F Lillian 3414 0.0107 #&gt; # ... with 2,215 more rows babynames %&gt;% filter(year == 2013, sex == &quot;F&quot;) #&gt; # A tibble: 19,203 x 5 #&gt; year sex name n prop #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 F Sophia 21171 0.0110 #&gt; 2 2013 F Emma 20905 0.0109 #&gt; 3 2013 F Olivia 18397 0.00958 #&gt; 4 2013 F Isabella 17599 0.00916 #&gt; 5 2013 F Ava 15225 0.00793 #&gt; 6 2013 F Mia 13127 0.00683 #&gt; 7 2013 F Emily 13107 0.00682 #&gt; 8 2013 F Abigail 12387 0.00645 #&gt; 9 2013 F Madison 10575 0.00551 #&gt; 10 2013 F Elizabeth 9431 0.00491 #&gt; # ... with 19,193 more rows babynames %&gt;% mutate( first = tolower(substr(name, 1, 1)), last = substr(name, nchar(name), nchar(name)) ) #&gt; Warning: The `printer` argument is soft-deprecated as of rlang 0.3.0. #&gt; This warning is displayed once per session. #&gt; # A tibble: 1,858,689 x 7 #&gt; year sex name n prop first last #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1880 F Mary 7065 0.0724 m y #&gt; 2 1880 F Anna 2604 0.0267 a a #&gt; 3 1880 F Emma 2003 0.0205 e a #&gt; 4 1880 F Elizabeth 1939 0.0199 e h #&gt; 5 1880 F Minnie 1746 0.0179 m e #&gt; 6 1880 F Margaret 1578 0.0162 m t #&gt; 7 1880 F Ida 1472 0.0151 i a #&gt; 8 1880 F Alice 1414 0.0145 a e #&gt; 9 1880 F Bertha 1320 0.0135 b a #&gt; 10 1880 F Sarah 1288 0.0132 s h #&gt; # ... with 1,858,679 more rows babynames %&gt;% arrange(desc(prop)) #&gt; # A tibble: 1,858,689 x 5 #&gt; year sex name n prop #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1880 M John 9655 0.0815 #&gt; 2 1881 M John 8769 0.0810 #&gt; 3 1880 M William 9531 0.0805 #&gt; 4 1883 M John 8894 0.0791 #&gt; 5 1881 M William 8524 0.0787 #&gt; 6 1882 M John 9557 0.0783 #&gt; 7 1884 M John 9388 0.0765 #&gt; 8 1882 M William 9298 0.0762 #&gt; 9 1886 M John 9026 0.0758 #&gt; 10 1885 M John 8756 0.0755 #&gt; # ... with 1,858,679 more rows babynames %&gt;% summarise(n = sum(n)) #&gt; # A tibble: 1 x 1 #&gt; n #&gt; &lt;int&gt; #&gt; 1 340851912 9.3.2 Group by 分組指令不會影響到原來的資料 head(mtcars) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 str(mtcars) #&gt; &#39;data.frame&#39;: 32 obs. of 11 variables: #&gt; $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... #&gt; $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... #&gt; $ disp: num 160 160 108 258 360 ... #&gt; $ hp : num 110 110 93 110 175 105 245 62 95 123 ... #&gt; $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... #&gt; $ wt : num 2.62 2.88 2.32 3.21 3.44 ... #&gt; $ qsec: num 16.5 17 18.6 19.4 17 ... #&gt; $ vs : num 0 0 1 1 0 1 0 1 1 1 ... #&gt; $ am : num 1 1 1 0 0 0 0 0 0 0 ... #&gt; $ gear: num 4 4 4 3 3 3 3 4 4 4 ... #&gt; $ carb: num 4 4 1 1 2 1 4 2 2 4 ... by_cyl &lt;- mtcars %&gt;% group_by(cyl) head(by_cyl) #&gt; # A tibble: 6 x 11 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 str(by_cyl) #&gt; Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 32 obs. of 11 variables: #&gt; $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... #&gt; $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... #&gt; $ disp: num 160 160 108 258 360 ... #&gt; $ hp : num 110 110 93 110 175 105 245 62 95 123 ... #&gt; $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... #&gt; $ wt : num 2.62 2.88 2.32 3.21 3.44 ... #&gt; $ qsec: num 16.5 17 18.6 19.4 17 ... #&gt; $ vs : num 0 0 1 1 0 1 0 1 1 1 ... #&gt; $ am : num 1 1 1 0 0 0 0 0 0 0 ... #&gt; $ gear: num 4 4 4 3 3 3 3 4 4 4 ... #&gt; $ carb: num 4 4 1 1 2 1 4 2 2 4 ... #&gt; - attr(*, &quot;vars&quot;)= chr &quot;cyl&quot; #&gt; - attr(*, &quot;drop&quot;)= logi TRUE #&gt; - attr(*, &quot;indices&quot;)=List of 3 #&gt; ..$ : int 2 7 8 17 18 19 20 25 26 27 ... #&gt; ..$ : int 0 1 3 5 9 10 29 #&gt; ..$ : int 4 6 11 12 13 14 15 16 21 22 ... #&gt; - attr(*, &quot;group_sizes&quot;)= int 11 7 14 #&gt; - attr(*, &quot;biggest_group_size&quot;)= int 14 #&gt; - attr(*, &quot;labels&quot;)=&#39;data.frame&#39;: 3 obs. of 1 variable: #&gt; ..$ cyl: num 4 6 8 #&gt; ..- attr(*, &quot;vars&quot;)= chr &quot;cyl&quot; #&gt; ..- attr(*, &quot;drop&quot;)= logi TRUE 但是分組結果會影響其他dplyr指令的計算結果: by_cyl %&gt;% summarise( disp = mean(disp), hp = mean(hp) ) #&gt; # A tibble: 3 x 3 #&gt; cyl disp hp #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 105. 82.6 #&gt; 2 6 183. 122. #&gt; 3 8 353. 209. by_cyl %&gt;% filter(disp == max(disp)) #&gt; # A tibble: 3 x 11 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 2 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 #&gt; 3 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 9.3.3 summarize() What other summary functions can we use inside the summarize() verb? Any function in R that takes a vector of values and returns just one. Here are just a few: mean(): the mean AKA the average sd(): the standard deviation, which is a measure of spread min() and max(): the minimum and maximum values respectively IQR(): Interquartile range sum(): the sum n(): a count of the number of rows/observations in each group. This particular summary function will make more sense when group_by() is covered in Section 5.5. 9.3.3.1 實驗 pipeline vs no pipeline 產生資料 year=c(1990, 1991, 1990, 1991, 1990, 1991, 1990, 1991, 1990, 1991) sex=c(&quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;) #value=c(1, 2, 3, 4, 5, 1, 2, 3, 4, 5) value=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) df&lt;-data.frame(sex,year,value) head(df) #&gt; sex year value #&gt; 1 f 1990 1 #&gt; 2 f 1991 2 #&gt; 3 f 1990 3 #&gt; 4 f 1991 4 #&gt; 5 f 1990 5 #&gt; 6 m 1991 6 9.3.3.2 不用 pipeline df&lt;-group_by(df,sex) ndf&lt;-mutate(df,rank=min_rank(value)) arrange(ndf,sex) #&gt; # A tibble: 10 x 4 #&gt; # Groups: sex [2] #&gt; sex year value rank #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 f 1990 1 1 #&gt; 2 f 1991 2 2 #&gt; 3 f 1990 3 3 #&gt; 4 f 1991 4 4 #&gt; 5 f 1990 5 5 #&gt; 6 m 1991 6 1 #&gt; 7 m 1990 7 2 #&gt; 8 m 1991 8 3 #&gt; 9 m 1990 9 4 #&gt; 10 m 1991 10 5 9.3.3.3 使用 pipeline ndf&lt;-df %&gt;% group_by(sex) %&gt;% mutate(rank = min_rank(value)) arrange(ndf,sex) #&gt; # A tibble: 10 x 4 #&gt; # Groups: sex [2] #&gt; sex year value rank #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 f 1990 1 1 #&gt; 2 f 1991 2 2 #&gt; 3 f 1990 3 3 #&gt; 4 f 1991 4 4 #&gt; 5 f 1990 5 5 #&gt; 6 m 1991 6 1 #&gt; 7 m 1990 7 2 #&gt; 8 m 1991 8 3 #&gt; 9 m 1990 9 4 #&gt; 10 m 1991 10 5 問題: 1. 如何知道min-rank(value)中的value 是全局或是欄位? hint: rm(value) 2. 會出現甚麼結果 df %&gt;% group_by(sex) %&gt;%str() nb &lt;-babynames %&gt;% group_by(name) babynames %&gt;% group_by(name) %&gt;% summarise(n = sum(n)) #&gt; # A tibble: 95,025 x 2 #&gt; name n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Aaban 87 #&gt; 2 Aabha 28 #&gt; 3 Aabid 5 #&gt; 4 Aabriella 15 #&gt; 5 Aada 5 #&gt; 6 Aadam 218 #&gt; 7 Aadan 122 #&gt; 8 Aadarsh 173 #&gt; 9 Aaden 4218 #&gt; 10 Aadesh 15 #&gt; # ... with 95,015 more rows babynames %&gt;% filter(name %in% c(&quot;John&quot;, &quot;Mary&quot;, &quot;William&quot;)) %&gt;% group_by(name, sex) %&gt;% summarise(n = sum(n)) #&gt; # A tibble: 6 x 3 #&gt; # Groups: name [?] #&gt; name sex n #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 John F 21657 #&gt; 2 John M 5095674 #&gt; 3 Mary F 4118058 #&gt; 4 Mary M 15158 #&gt; 5 William F 15911 #&gt; 6 William M 4071645 babynames %&gt;% group_by(year, sex) %&gt;% mutate(rank = min_rank(desc(n))) %&gt;% tail() #&gt; # A tibble: 6 x 6 #&gt; # Groups: year, sex [1] #&gt; year sex name n prop rank #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2015 M Zyah 5 0.00000247 12008 #&gt; 2 2015 M Zykell 5 0.00000247 12008 #&gt; 3 2015 M Zyking 5 0.00000247 12008 #&gt; 4 2015 M Zykir 5 0.00000247 12008 #&gt; 5 2015 M Zyrus 5 0.00000247 12008 #&gt; 6 2015 M Zyus 5 0.00000247 12008 9.3.3.4 Combining to answer more complex questions ———————————– 9.3.3.4.1 How many Hadley’s? babynames %&gt;% filter(name == &quot;Hadley&quot;) %&gt;% group_by(sex) %&gt;% summarise(n = sum(n)) #&gt; # A tibble: 2 x 2 #&gt; sex n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 F 21119 #&gt; 2 M 1814 9.3.3.4.2 The travesty library(ggplot2) #&gt; #&gt; Attaching package: &#39;ggplot2&#39; #&gt; The following object is masked from &#39;mtcars&#39;: #&gt; #&gt; mpg babynames %&gt;% filter(name == &quot;Hadley&quot;) %&gt;% ggplot(aes(year, n)) + geom_line(aes(colour = sex)) "],
["basic-plot.html", "Chapter 10 Basic Plot 10.1 reference 10.2 basic 10.3 Histograms and Density Plots 10.4 Combining Plots 10.5 Add texts within the graph 10.6 函數畫圖", " Chapter 10 Basic Plot 10.1 reference Quric R windows() ## create window to plot your file ## … your plotting code here … dev.off() Note: This will delete your current plots in the RStudio Plots Pane. If you have multiple graphics devices open, repeat this command until the output displays null device. 10.2 basic Creating a Graph In R, graphs are typically created interactively. 10.2.1 Creating a Graph attach(mtcars) #&gt; The following object is masked from package:ggplot2: #&gt; #&gt; mpg #&gt; The following objects are masked from mtcars (pos = 9): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt plot(wt, mpg) abline(lm(mpg~wt)) title(&quot;Regression of MPG on Weight&quot;) The plot( ) function opens a graph window and plots weight vs. miles per gallon. The next line of code adds a regression line to this graph. The final line adds a title. plot example click to view Saving Graphs You can save the graph in a variety of formats from the menu File -&gt; Save As. You can also save the graph via code using one of the following functions. Function Output to pdf(“mygraph.pdf”) pdf file win.metafile(“mygraph.wmf”) windows metafile png(“mygraph.png”) png file jpeg(“mygraph.jpg”) jpeg file bmp(“mygraph.bmp”) bmp file postscript(“mygraph.ps”) postscript file See input/output for details. Viewing Several Graphs Creating a new graph by issuing a high level plotting command (plot, hist, boxplot, etc.) will typically overwrite a previous graph. To avoid this, open a new graph window before creating a new graph. To open a new graph window use one of the functions below. Function Platform windows() Windows X11() Unix quartz() Mac You can have multiple graph windows open at one time. See help(dev.cur) for more details. 10.3 Histograms and Density Plots 10.3.1 Histograms You can create histograms with the function hist(x) where x is a numeric vector of values to be plotted. The option freq=FALSE plots probability densities instead of frequencies. The option breaks= controls the number of bins. 10.3.1.1 Simple Histogram hist(mtcars$mpg) simple histogram click to view 10.3.1.2 Colored Histogram with Different Number of Bins hist(mtcars$mpg, breaks=12, col=&quot;red&quot;) colored histogram click to view 10.3.1.3 Add a Normal Curve (Thanks to Peter Dalgaard) x &lt;- mtcars$mpg h&lt;-hist(x, breaks=10, col=&quot;red&quot;, xlab=&quot;Miles Per Gallon&quot;, main=&quot;Histogram with Normal Curve&quot;) xfit&lt;-seq(min(x),max(x),length=40) yfit&lt;-dnorm(xfit,mean=mean(x),sd=sd(x)) yfit &lt;- yfit*diff(h$mids[1:2])*length(x) lines(xfit, yfit, col=&quot;blue&quot;, lwd=2) histogram with normal curve click to view Histograms can be a poor method for determining the shape of a distribution because it is so strongly affected by the number of bins used. To practice making a density plot with the hist() function, try this exercise. 10.3.2 Kernel Density Plot Kernal density plots are usually a much more effective way to view the distribution of a variable. Create the plot using plot(density(x)) where x is a numeric vector. d &lt;- density(mtcars$mpg) # returns the density data plot(d) # plots the results simple density plot click to view 10.3.2.1 Filled Density Plot d &lt;- density(mtcars$mpg) plot(d, main=&quot;Kernel Density of Miles Per Gallon&quot;) polygon(d, col=&quot;red&quot;, border=&quot;blue&quot;) colored density plot click to view 10.3.3 Comparing Groups VIA Kernal Density The sm.density.compare( ) function in the sm package allows you to superimpose the kernal density plots of two or more groups. The format is sm.density.compare(x, factor) where x is a numeric vector and factor is the grouping variable. 10.3.3.1 Compare MPG distributions for cars with 4,6, or 8 cylinders library(sm) attach(mtcars) #create value labels cyl.f &lt;- factor(cyl, levels= c(4,6,8), labels = c(&quot;4 cylinder&quot;, &quot;6 cylinder&quot;, &quot;8 cylinder&quot;)) #plot densities sm.density.compare(mpg, cyl, xlab=&quot;Miles Per Gallon&quot;) title(main=&quot;MPG Distribution by Car Cylinders&quot;) #add legend via mouse click colfill&lt;-c(2:(2+length(levels(cyl.f)))) legend(locator(1), levels(cyl.f), fill=colfill) 10.4 Combining Plots R makes it easy to combine multiple plots into one overall graph, using either the par( ) or layout( ) function. With the par( ) function, you can include the option mfrow=c(nrows, ncols) to create a matrix of nrows x ncols plots that are filled in by row. mfcol=c(nrows, ncols) fills in the matrix by columns. #4 figures arranged in 2 rows and 2 columns attach(mtcars) #&gt; The following objects are masked from mtcars (pos = 3): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following object is masked from package:ggplot2: #&gt; #&gt; mpg #&gt; The following objects are masked from mtcars (pos = 10): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt par(mfrow=c(2,2)) plot(wt,mpg, main=&quot;Scatterplot of wt vs. mpg&quot;) plot(wt,disp, main=&quot;Scatterplot of wt vs disp&quot;) hist(wt, main=&quot;Histogram of wt&quot;) boxplot(wt, main=&quot;Boxplot of wt&quot;) dev.off() #&gt; null device #&gt; 1 2 x2 layout click to view # 3 figures arranged in 3 rows and 1 column attach(mtcars) #&gt; The following objects are masked from mtcars (pos = 3): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following objects are masked from mtcars (pos = 4): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following object is masked from package:ggplot2: #&gt; #&gt; mpg #&gt; The following objects are masked from mtcars (pos = 11): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt par(mfrow=c(3,1)) hist(wt) hist(mpg) hist(disp) dev.off() #&gt; null device #&gt; 1 3 x 1 layout 函數 layout( ) 的使用方法為 layout(mat) 其中 mat 的元素用來指定圖形號碼。例如分成4個格子,順序為左右上下(byrow=TRUE) 1在第一ROW,占用[1,1]-[1,2],2,3,分別占用[2,1]和[2,2] # One figure in row 1 and two figures in row 2 attach(mtcars) #&gt; The following objects are masked from mtcars (pos = 3): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following objects are masked from mtcars (pos = 4): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following objects are masked from mtcars (pos = 5): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following object is masked from package:ggplot2: #&gt; #&gt; mpg #&gt; The following objects are masked from mtcars (pos = 12): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE)) hist(wt) hist(mpg) hist(disp) dev.off() #&gt; null device #&gt; 1 Optionally, you can include widths= and heights= options in the layout( ) function to control the size of each figure more precisely. These options have the form widths= a vector of values for the widths of columns heights= a vector of values for the heights of rows. Relative widths are specified with numeric values. Absolute widths (in centimetres) are specified with the lcm() function. note: par(mar) 列出margin par(mar=c(1,1,1,1)) 更動margin 錯誤於plot.new() : figure margins too large 有兩個原因：1 是畫布過小 2，當前畫布的上下左右距離過大 解決第二個原因 默認的畫布上邊款的距離為： 預設為 c(5, 4, 4, 2) + 0.1. 對應 c(bottom, left, top, right) 我們可以講其設置為0. op &lt;- par(mar = rep(0, 4)) # op 之前的margin = 5.1 4.1 4.1 2.1 plot.new() # 畫圖 par(op) # 改回原先的margin par(mar = rep(2, 4)) # One figure in row 1 and two figures in row 2 # row 1 is 1/3 the height of row 2 # column 2 is 1/4 the width of the column 1 attach(mtcars) #&gt; The following objects are masked from mtcars (pos = 3): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following objects are masked from mtcars (pos = 4): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following objects are masked from mtcars (pos = 5): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following objects are masked from mtcars (pos = 6): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt #&gt; The following object is masked from package:ggplot2: #&gt; #&gt; mpg #&gt; The following objects are masked from mtcars (pos = 13): #&gt; #&gt; am, carb, cyl, disp, drat, gear, hp, mpg, qsec, vs, wt layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE), widths=c(3,1), heights=c(1,2)) hist(wt) hist(mpg) hist(disp) multiplot layout with fine control click to view See help(layout) for more details. Creating a figure arrangement with fine control In the following example, two box plots are added to scatterplot to create an enhanced graph. par(mar = rep(2, 4)) # Add boxplots to a scatterplot par(fig=c(0,0.8,0,0.8), new=TRUE) #&gt; Warning in par(fig = c(0, 0.8, 0, 0.8), new = TRUE): calling par(new=TRUE) #&gt; with no plot plot(mtcars$wt, mtcars$mpg, xlab=&quot;Car Weight&quot;, ylab=&quot;Miles Per Gallon&quot;) par(fig=c(0,0.8,0.55,1), new=TRUE) boxplot(mtcars$wt, horizontal=TRUE, axes=FALSE) par(fig=c(0.65,1,0,0.8),new=TRUE) boxplot(mtcars$mpg, axes=FALSE) mtext(&quot;Enhanced Scatterplot&quot;, side=3, outer=TRUE, line=-3) To understand this graph, think of the full graph area as going from (0,0) in the lower left corner to (1,1) in the upper right corner. The format of the fig= parameter is a numerical vector of the form c(x1, x2, y1, y2). The first fig= sets up the scatterplot going from 0 to 0.8 on the x axis and 0 to 0.8 on the y axis. The top boxplot goes from 0 to 0.8 on the x axis and 0.55 to 1 on the y axis. I chose 0.55 rather than 0.8 so that the top figure will be pulled closer to the scatter plot. The right hand boxplot goes from 0.65 to 1 on the x axis and 0 to 0.8 on the y axis. Again, I chose a value to pull the right hand boxplot closer to the scatterplot. You have to experiment to get it just right. fig= starts a new plot, so to add to an existing plot use new=TRUE. You can use this to combine several plots in any arrangement into one graph. 10.5 Add texts within the graph The text() function can be used to draw text inside the plotting area. A simplified format of the function is : text(x, y, labels) x and y: 文字座標; labels: 例如 “a label” 範例 : d&lt;-head(mtcars) plot(d[,&#39;wt&#39;], d[,&#39;mpg&#39;], main=&quot;Milage vs. Car Weight\\n~~~~~~~~~~~~~~~~~~~&quot;, xlab=&quot;Weight&quot;, ylab=&quot;Miles/(US) gallon&quot;, pch=19, col=&quot;darkgreen&quot;) text(d[,&#39;wt&#39;], d[,&#39;mpg&#39;], row.names(d), cex=0.65,pos=3,col=&quot;red&quot;) 10.5.1 Add text in the margins of the graph 在圖形周圍給文字: mtext(text, side=3) text : 例如“a label” side : 哪一側 : 順時針 1: 下 2: 左 3: 上 4: 又 範例 : plot(1:10, 1:10, main=&quot;mtext(...) examples\\n~~~~~~~~~~~&quot;) mtext(&quot;Magic function&quot;, side=3) 10.5.2 Add mathematical annotation to a plot plot(1:10, 1:10, main=&quot;text(...) examples\\n~~~~~~~~~~~&quot;) text(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y)) text(7, 4, expression(bar(x) == sum(frac(x[i], n), i==1, n))) 10.6 函數畫圖 eq = function(x){x*x} plot(eq(1:1000), type=&#39;l&#39;) 問題是如果x座標的增加不是1單位? x&lt;-seq(1,10,0.1) y&lt;-exp(x) x&lt;-y eq = function(x){x*x} plot(x,eq(x), type=&#39;l&#39;) eq = function(x){x*x} curve(eq, from=1, to=50, xlab=&quot;x&quot;, ylab=&quot;y&quot;) 問題:解釋為何錯誤 eq = function(x){x*x} y&lt;-eq(1:50) curve(y, xlab=&quot;x&quot;, ylab=&quot;y&quot;) #&gt; Error in y(x): #&gt; could not find function &quot;y&quot; 問題:如何修正下面的錯誤? eq = function(x){x*x} z&lt;-1:50 curve(eq(z), xlab=&quot;x&quot;, ylab=&quot;y&quot;) solution: "],
["rbook-.html", "Chapter 11 rbook 提要 11.1 index.Rmd 11.2 其他_output.yml 範例 11.2 _output.yml 範例 11.3 .travis.yml 11.4 紀錄", " Chapter 11 rbook 提要 11.1 index.Rmd 通常是一系列文章裡面的第一個文件。其他rmd文件的yml 頭部都可以統一放在這裡。 下面是一些選項,可以自行添加到上面: bibliography: [book.bib, packages.bib] biblio-style: apalike link-citations: yes github-repo: rstudio/bookdown-demo bibliography 暫時沒有參考文件檔,所以我沒有放. 11.2 其他_output.yml 範例 簡單講,_output.yml放的是輸出到哪裡?gitbook? pdf? 或者是簡單html格式。 11.2 _output.yml 範例 bookdown::gitbook: css: style.css config: toc: before: | &lt;li&gt;&lt;a href=&quot;./&quot;&gt;A Minimal Book Example&lt;/a&gt;&lt;/li&gt; after: | &lt;li&gt;&lt;a href=&quot;https://github.com/rstudio/bookdown&quot; target=&quot;blank&quot;&gt;Published with bookdown&lt;/a&gt;&lt;/li&gt; edit: https://github.com/rstudio/bookdown-demo/edit/master/%s download: [&quot;pdf&quot;, &quot;epub&quot;] # bookdown::pdf_book: # latex_engine: &quot;xelatex&quot; # keep_tex: true # includes: # in_header: header.tex bookdown::pdf_book: includes: in_header: latex/preamble.tex before_body: latex/before_body.tex after_body: latex/after_body.tex keep_tex: true dev: &quot;cairo_pdf&quot; latex_engine: xelatex citation_package: natbib pandoc_args: [&quot;--top-level-division=chapter&quot;, &quot;--lua-filter=latex/sidebar.lua&quot;] template: null quote_footer: null toc_unnumbered: false number_sections: true --- output: html_document: highlight: tango number_sections: yes toc: yes --- 上面這段YML會被解譯到下面的R程式碼。 猜測:html_document對應rmarkdown::html_document 例如, number_sections: yes 會被當成html_document()的參數轉譯: highlight: tango 對應到參數(沒有在下面) rmarkdown::html_document( theme= &quot;lumen&quot;, template= template, css= css, toc= toc, toc_float= TRUE, toc_depth= 2, number_sections= number_sections, df_print = &quot;paged&quot;, code_folding = code_folding, includes = includes(before_body = header) ) } 11.3 .travis.yml rmarkdown and travis 應該是用來指導怎麼建立專案的一個yml。 已知的部分有: directories : 可以指定子目錄,用來放暫存檔案(一些翻譯過程產生的中間黨),否則每個RMD都會產生一個組目錄。 language: R sudo: false cache: packages: true directories: - _bookdown_files - $HOME/.npm pandoc_version: 2.1.1 11.4 紀錄 before_chapter_script: “common.R” 前面要有兩個空白 if(FALSE) { ’ 兩個地方可以放, 1) 一個是在_bookdown.yml中的最後一行: before_chapter_script: “common.R” 2)一個是在每個RMD的第一個chunk執行 source(“common.R”) ’ } "],
["gitbook-introduction.html", "Chapter 12 gitbook introduction 12.1 _output.yml: 12.2 _bookdown.yml: 12.2 new_session 注意事項 12.3 index.rmd 12.4 執行 12.5 加入:Travis", " Chapter 12 gitbook introduction 3個地方需要注意: _output.yml _bookdown.yml index.rmd 12.1 _output.yml: bookdown::gitbook: css: style.css split_by: chapter config: toc: collapse: subsection before: | &lt;li&gt;&lt;a href=&quot;./&quot;&gt;A Minimal Bookdown Book&lt;/a&gt;&lt;/li&gt; after: | &lt;li&gt;&lt;a href=&quot;https://github.com/rstudio/bookdown&quot; target=&quot;blank&quot;&gt;Published with bookdown&lt;/a&gt;&lt;/li&gt; bookdown::pdf_book: includes: in_header: preamble.tex latex_engine: xelatex citation_package: natbib bookdown::epub_book: stylesheet: style.css 上面要修改的部分只有書名(title of book) 12.2 _bookdown.yml: book_filename: &quot;bookdown-xx&quot; chapter_name: &quot;Chapter &quot; repo: https://github.com/seankross/bookdown-start output_dir: docs rmd_files: [&quot;index.Rmd&quot;, &quot;01-Introduction.Rmd&quot;, &quot;02-Diving-In.Rmd&quot;] clean: [packages.bib, bookdown.bbl] new_session: yes 欄位 book_filename :書名(PDF 或EPUB)例如本例的書名為bookdown_xx.pdf。 欄位 chapter_name:每個章節的前綴,例如 01-Introduction.Rmd 第一個H1 標籤為 # Introduction ,會變成 “Chapter 1 Introduction”。 欄位 repo field just designates a GitHub repository associated with this book but this is not a required field. 欄位 output_dir: HTML檔案的輸出位置。同時也是pdf檔案的輸出位置。如果沒有設定這個欄位,那麼預設輸出位置是 _book/ 。 欄位 rmd_files:這是選擇性的,如果沒有設定,那麼專案子目錄下的所有RMD都會被rendered。 欄位 new_session: 這也是選擇性的。如果是 new_session: yes 那麼每個RMD都在新的R連結(session)描繪(rendered)，否則在同一個session. 12.2 new_session 注意事項 但是我注意到,new_session 設定為yes的時候,md檔案會被留下,而設定為no的時候,則不會。 同時,在new_session=no的時候,可以指定子目錄中的RMD檔案。 例如 language: ui: chapter_name: &quot;Chapter &quot; new_session: no after_chapter_script: clear_vars_and_pkgs.R rmd_files: - &quot;index.Rmd&quot; - &quot;my_sub_dir/chapter1.Rmd&quot; - &quot;my_sub_dir/chapter2.Rmd&quot; 注意: new_session=yes 的時候,會產生md檔案,如果上傳到Github會被jekyll解讀 要避免這個情況發生,推測兩個解法 1. (OK) 在docs中放入.nojkeyll 這個檔案(在bash中執行指令 touch .nojkeyll) 1. (不確定)在_bookdown.yml 的欄位after_chapter_script:中指定執行指令殺掉所有md檔案 12.3 index.rmd 另外一個相關設定的地方是index.rmd 。這個檔案用來設定書的cover, 和前幾頁。因此Preface 和簡介可以放在這個檔案。這個檔案的前幾行通常是有關yaml的一些設定,例如 --- title: &quot;XXX title&quot; author: &quot;len jwj cen&quot; date: &quot;2018-1-1&quot; site: bookdown::bookdown_site documentclass: book #bibliography: [book.bib] #biblio-style: apalike link-citations: yes github-repo: seankross/bookdown-start url: &#39;http\\://seankross.com/bookdown-start/&#39; description: &quot;gitbook&#39;s simple setup&quot; --- 應該更改的有 title, author, date, github-repo, url, and description 欄位。 其他設定有 cover-image:圖檔位置。 site: bookdown::bookdown_site 有這行就不用設定_site.yml。 12.4 執行 bookdown::render_book(“index.Rmd”) 12.5 加入:Travis 使用 Travis 產生書一需要3個檔案,這三個黨要放在github repo的根目錄: 3個檔案的前2個,可以直接從這裡複製: ### .Rbuildignore ^.*.Rproj$ .Rproj.user$ .travis.yml$ 12.5.1 .travis.yml: language: r cache: packages script: - Rscript -e &#39;bookdown::render_book(&quot;index.rmd&quot;)&#39; 12.5.2 DESCRIPTION 要讓travis誤認為package 所以,只是放著,內容不管 Package: placeholder Title: Does not matter. Version: 0.0.1 Imports: bookdown Remotes: rstudio/bookdown "],
["sample-and-distribution-01.html", "Chapter 13 Sample and Distribution 01 13.1 排列組合與概率的計算 13.2 distribution", " Chapter 13 Sample and Distribution 01 ## 隨機抽樣 函數sample(x,n,replace=FALSE ). 其中x為要抽取的向量, n為樣本容量. replace 預設為false no replacement, 等機率: 例如從52張撲克牌中抽取5張: sample(1:52, 5) #&gt; [1] 5 43 31 8 1 replacement: 例如拋一枚均勻的硬幣10次 sample(c(&quot;H&quot;, &quot;T&quot;), 10, replace=T) #&gt; [1] &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; 練習:一棵骰子擲10次可表示為: 不等可能的隨機抽樣: sample(x, n, replace=TRUE, prob=y) prob=y指定x中元素出現的概率, 向量y與x等長度. 例如一娃娃機取出成功的概率為0.6, 那麼10次的試驗為: sample(c(&quot;sucess&quot;, &quot;fail&quot;), 10, replace=T, prob=c(0.6,0.4)) #&gt; [1] &quot;fail&quot; &quot;sucess&quot; &quot;sucess&quot; &quot;fail&quot; &quot;fail&quot; &quot;sucess&quot; &quot;sucess&quot; #&gt; [8] &quot;sucess&quot; &quot;fail&quot; &quot;sucess&quot; 13.1 排列組合與概率的計算 例 從一副52張撲克中取4張, 求以下事件的概率: 1. 抽取的4張依次為紅心A，方塊A，黑桃A和梅花A的概率; 2. 一次抽取4張為紅心A，方塊A，黑桃A和梅花A的概率. his summation expression \\(\\sum_{i=1}^n X_i\\) appears inline. 解 1) 抽取的4張是有次序的, 因此使用排列來求解. 所求的事件(記為A)概率為 \\(P(A)=\\frac{1}{52 \\times 51 \\times 50 \\times 49}\\) 利用R函數 1/prod(52:49) #&gt; [1] 1.54e-07 沒有次序的, 可以使用組合數來求解. \\[ P(B)=\\frac{1}{(52,4)} \\] 其中 \\((n,m)=\\frac{n!}{m!(n-m)!}\\),可以利用函數choose(),例如 1/choose(52,4) #&gt; [1] 3.69e-06 13.2 distribution 標準表格上下沒有線條,左右有 名稱 R函數 選項 beta beta shape1, shape2 binomial binom size, prob Cauchy cauchy location=0, scale=1 chi-sqaured (\\(\\chi^2\\)) chisq df, ncp exponential exp rate Fisher (F) f df1, df2, ncp gamma gamma shape, scale=1 geometric geom prob hypergeometric hyper m, n, k lognormal lnorm meanlog=0, sdlog=1 logistic logis location=0, scale=1 multinomial multinom size, prob normal norm mean=0, sd=1 negative binomial nbinom size, prob Poisson pois lambda Student’s (t) t df uniform unif min=0, max=1 Weibull weibull shape, scale=1 Wilcoxon’s statistics wilcox m, n signrank n 對於所給的分佈名稱，有四類。 以func為例， 四類函數的對應為: 1. 「d」概率密度函數: dfunc(x, p1, p2, …), x為數值向量; 1. 「p」(累積)分佈函數: pfunc(q, p1, p2, …), q為數值向量; 1. 「q」分位數函數: qfunc(p, p1, p2, …), p為由概率構成的向量; 1. 「r」隨機數函數: rfunc(n, p1, p2, …), n為生成數據的個數 這四類函數的第一個參數是有規律的: 形為dfunc的函數為x，pfunc的函數為q，qfunc的函數為p，rfunc的函數為n note: (但rhyper和rwilcox是特例，他們的第一個參數為nn). 非中心參數(non-centrality parameter)僅對CDF和 少數其它幾個函數有效. \\[ \\frac{{\\sum\\limits_{i = 1}^n {{x_i} - n\\mu } }}{{\\sqrt {n{\\sigma ^2}} }} \\sim N(0,1) \\] \\[ \\bar X = \\frac{{\\sum_{i = 1}^n {{x_i} } }}{n} \\sim N(\\mu, \\sigma^2/n) \\] uniform a~b \\[\\mu = (a+b)/2\\] \\[\\sigma^2=\\frac{(b-a)^2}{12} \\] data的每一個ROW有sample size (=i=column) 共1000次(=N=row) N=1000 i=3 #sample size mu=0.5 sigma=1/sqrt(12) data&lt;-matrix(runif(i*N),ncol=i) rs&lt;-rowSums(data) rs&lt;-rs/i z&lt;-(rs-mu)/(sigma/sqrt(i)) hist(z) lines(density(z), col = &#39;red&#39;, lwd = 3) x&lt;-z curve(dnorm(x), col = &#39;blue&#39;, lwd = 3, lty = 3, add = T) rug(sample(z,100)) limite.central &lt;- function (r = runif, distpar = c(0, 1), m = .5, s = 1 / sqrt(12), n = c(1, 3, 10, 30), N = 1000) { for (i in n) { if (length(distpar) == 2) { x &lt;-matrix(r(i * N, distpar[1], distpar[2]), nc = i) } else { x &lt;-matrix(r(i * N, distpar), nc = i) } x &lt;-(apply(x, 1, sum) - i * m) / (sqrt(i) * s) hist(x, col = &#39;light blue&#39;, probability = T, main = paste(&quot;n=&quot;, i), ylim = c(0, max(.4, density(x) $y))) lines(density(x), col = &#39;red&#39;, lwd = 3) curve(dnorm(x), col = &#39;blue&#39;, lwd = 3, lty = 3, add = T) if (N &gt; 100) { rug(sample(x, 100)) } else { rug(x) } } } op &lt;- par(mfrow=c(2,2)) limite.central(rbinom, distpar=c(10 ,0.1), m=1, s=0.9) par(op) apply(x,1,sum) 第2個參數1表示row 方向,如果是2表示column 和matlab 相反。 "]
]
